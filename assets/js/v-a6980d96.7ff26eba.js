"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[7920],{3014:(o,e,a)=>{a.r(e),a.d(e,{data:()=>n});const n={key:"v-a6980d96",path:"/prototypy/lancuch-prototypow/",title:"Dziedziczenie prototypowe",lang:"pl-PL",frontmatter:{permalink:"/prototypy/lancuch-prototypow"},excerpt:"",headers:[{level:2,title:"Dziedziczenie po Object.prototype",slug:"dziedziczenie-po-object-prototype",children:[]},{level:2,title:"proto vs [[Prototype]] vs Object.prototype",slug:"proto-vs-prototype-vs-object-prototype",children:[]},{level:2,title:"Inne prototypy",slug:"inne-prototypy",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"prototypy/01-dziedziczenie-prototypowe.md",git:{}}},9295:(o,e,a)=>{a.r(e),a.d(e,{default:()=>s});const n=(0,a(6252).uE)('<h1 id="dziedziczenie-prototypowe" tabindex="-1"><a class="header-anchor" href="#dziedziczenie-prototypowe" aria-hidden="true">#</a> Dziedziczenie prototypowe</h1><p>W tym dziale będę chciał omówić dziedziczenie w JavaScript, a także budowę i zachowanie obiektów. Omówimy wewnętrzną właściwość <code>[[Prototype]]</code> a także prototypy obiektów, które są używane przy tworzeniu obiektów w JavaScript. Są to tematy, którymi nie będziecie zaprzątać sobie głowy jako programiści JavaScript. Być może nigdy świadomie nie zmodyfikujecie prototypu obiektu. Wydaje mi się jednak, że wiedza o tym jak działają obiekty pod spodem, pomoże lepiej zrozumieć ten język.</p><p>Przede wszystkim warto wspomnieć, że jest to język inny niż Java czy C++. Trudno tutaj mówić o typowym dziedziczeniu. Częściej spotkacie się z określeniem dziedziczenie prototypowe. W każdym razie nie warto skupiać się na terminologii, ale na tym jak to w JavaScript działa.</p><h2 id="dziedziczenie-po-object-prototype" tabindex="-1"><a class="header-anchor" href="#dziedziczenie-po-object-prototype" aria-hidden="true">#</a> Dziedziczenie po Object.prototype</h2><p>Zawsze jak stworzymy jakiś obiekt w JavaScript, dziedziczy on po globalnym obiekcie Object, a dokładniej po tym co znajduje się w <code>Objec.prototype</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> personA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n  surname<span class="token operator">:</span> <span class="token string">&#39;Rambo&#39;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>W chwili tworzenia obiektu ustawiana jest jego wewnętrzna właściwość <code>[[Prototype]]</code>. W dokumentacji jest ona zapisana z dwoma nawiasami kwadratowymi. Jeżeli zastanawiacie się jak dostać się do właściwości <code>[[Prototype]]</code> to jest do tego specjalny getter i setter o nazwie <code>__proto__</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>personA<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><div class="language-powershell ext-powershell line-numbers-mode"><pre class="language-powershell"><code><span class="token punctuation">{</span>name: <span class="token string">&quot;John&quot;</span><span class="token punctuation">,</span> surname: <span class="token string">&quot;Rambo&quot;</span><span class="token punctuation">}</span>\nname: <span class="token string">&quot;John&quot;</span>\nsurname: <span class="token string">&quot;Rambo&quot;</span>\n__proto__: Object\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Gdy wypiszemy sam obiekt do przeglądarki to widzimy, że obiekt ten ma dodatkową właściwość <code>__proto__</code>. Jest to właśnie getter i setter do ustawiania prototypu obiektu. To właśnie do tej właściwości dopisana jest cała zawartość z <code>Object.prototype</code>.</p><p>Tak jak wspomniałem na początku, wszystkie obiekty w JavaScript wywodzą się z globalnego obiektu <code>Object</code> ,a dokładniej dziedziczą z <code>Object.prototype</code>. <code>Object.prototype</code> to taka podstawowa funkcjonalność dla każdego obiektu. W <code>Object.prototpype</code> znajdują się gotowe pola i metody, które od razu możemy wykorzystać do pracy z obiektem.</p><p>Gdy wypiszemy właściwość <code>__proto__</code> do konsoli:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>personA<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>zobaczymy, że posiada ona kilka zdefiniowanych metod jak <code>toString</code>, <code>hasOwnProperty</code>, <code>isPrototypeOf</code>:</p><div class="language-powershell ext-powershell line-numbers-mode"><pre class="language-powershell"><code>constructor: ƒ Object<span class="token punctuation">(</span><span class="token punctuation">)</span>\nhasOwnProperty: ƒ hasOwnProperty<span class="token punctuation">(</span><span class="token punctuation">)</span>\nisPrototypeOf: ƒ isPrototypeOf<span class="token punctuation">(</span><span class="token punctuation">)</span>\npropertyIsEnumerable: ƒ propertyIsEnumerable<span class="token punctuation">(</span><span class="token punctuation">)</span>\ntoLocaleString: ƒ toLocaleString<span class="token punctuation">(</span><span class="token punctuation">)</span>\ntoString: ƒ toString<span class="token punctuation">(</span><span class="token punctuation">)</span>\nvalueOf: ƒ valueOf<span class="token punctuation">(</span><span class="token punctuation">)</span>\n__defineGetter__: ƒ __defineGetter__<span class="token punctuation">(</span><span class="token punctuation">)</span>\n__defineSetter__: ƒ __defineSetter__<span class="token punctuation">(</span><span class="token punctuation">)</span>\n__lookupGetter__: ƒ __lookupGetter__<span class="token punctuation">(</span><span class="token punctuation">)</span>\n__lookupSetter__: ƒ __lookupSetter__<span class="token punctuation">(</span><span class="token punctuation">)</span>\nget __proto__: ƒ __proto__<span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token function">set</span> __proto__: ƒ __proto__<span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Te metody pochodzą właśnie z <code>Object.prototype</code>. Gdy stworzymy nowy obiekt, to JavaScript łączy <code>Object.prototype</code> z wewnętrzną właściwością obiektu o nazwie <code>[[Prototype]]</code>. Do tej właściwości możemy się właśnie odwołać przez getter i setter o nazwie <code>__proto__</code>. Nawet jeżeli stworzymy pusty obiekt to i tak otrzyma on prototyp z <code>Object.prototype</code>. Tak to działa w JavaScript, każdy obiekt ma zapewniony jakiś prototyp.</p><p>W niektórych przypadkach możemy stworzyć obiekt bez prototypu. Gdy omawialiśmy metodę <code>Object.create</code> mówiłem, że wywołanie jej z wartością <code>null</code>, stworzy obiekt bez prototypu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> empty <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>W ten sposób tworzymy obiekt, którego wewnętrzna właściwość <code>[[Prototype]]</code> ustawiona jest na <code>null</code>. W tej sytuacji, obiekt ten nie ma żadnych metod i właściwości, które zapewnia <code>Object.prototype</code>. Jest to dopuszczalne w JavaScript, zazwyczaj jednak nie będziemy spotykać się z takimi obiektami.</p><h2 id="proto-vs-prototype-vs-object-prototype" tabindex="-1"><a class="header-anchor" href="#proto-vs-prototype-vs-object-prototype" aria-hidden="true">#</a> <strong>proto</strong> vs [[Prototype]] vs Object.prototype</h2><p>Wrócę jeszcze na chwilę do nazewnictwa i definicji, które pojawiają się przy omawianiu prototypów. Niestety wszystkie nazwy są do siebie podobne, a wcale nie oznaczają tego samego:</p><ul><li><code>[[Prototype]]</code> - zapis <code>[[Prototype]]</code> w podwójnych klamrach to określenie wewnętrznej właściwości obiektu, który tworzymy. Nie mamy dostępu bezpośrednio do tej właściwości przez taką nazwę, tak jest ona po prostu określona w dokumentacji. Do tej właściwości dopisywany jest prototyp z innego obiektu zazwyczaj będzie to prototyp z <code>Object.prototype</code>. Jest to więc miejsce, w którym przetrzymywany jest prototyp obiektu z którego został stworzony nasz nowy obiekt.</li><li><code>__proto__</code> - zapis z podwójnymi podkreśleniami na początku i końcu słowa <code>proto</code> to setter i getter do wewnętrznej właściwości obiektu <code>[[Prototype]]</code>. Między innymi ten akcesor pozwala nam pobrać prototyp, który posłużył do stworzenia obiektu. Również przez tą właściwość możemy ręcznie ustawić prototyp obiektu. Ponieważ nie możemy się dostać do obiektu przez nazwę <code>[[Prototype]]</code> to mamy dostęp przez ten akcesor.</li><li><code>Object.prototype</code> to prototyp dla obiektów. Gdy obiekty są tworzone, prototyp ten jest wykorzystywany przez JavaScript i ustawiony na wewnętrznej właściwości <code>[[Prototype]]</code>. W <code>Object.prototype</code> istnieją pewne gotowe funkcjonalności, które są przekazywane właśnie przez dziedziczenie prototypowe. Dla uproszczenia posługuję się ciągle <code>Object.prototype</code>, ale mamy też <code>Array.prototype</code>, <code>String.prototype</code> czy <code>Function.prototype</code>. Jak się można domyśleć są to prototypy do budowy odpowiednich podtypów w JavaScript.</li></ul><p>Podsumowując: wszelkie prototypy jak <code>Object.prototype</code> są wykorzystane do zbudowania podstawowych funkcjonalności w obiektach JavaScript. Funkcjonalności te są umieszczone w wewnętrznej właściwości <code>[[Prototype]]</code>, do której mamy dostęp przez akcesor <code>__proto__</code>.</p><h2 id="inne-prototypy" tabindex="-1"><a class="header-anchor" href="#inne-prototypy" aria-hidden="true">#</a> Inne prototypy</h2><p>W JavaScript istnieją także inne prototypy jak <code>Array.prototype</code>, <code>String.prototype</code> czy <code>Boolean.prototype</code> i więcej. W przyszłości mogą być dodawane kolejne.</p><p>Jeżeli stworzymy obiekt tablicy to nasz obiekt będzie dziedziczył po <code>Array.prototype</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>\n<span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span>\n<span class="token number">1</span><span class="token operator">:</span> <span class="token number">2</span>\n<span class="token number">2</span><span class="token operator">:</span> <span class="token number">3</span>\nlength<span class="token operator">:</span> <span class="token number">3</span>\n__proto__<span class="token operator">:</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Wypisując do konsoli obiekt, możemy zobaczyć, że <code>__proto__</code> jest typu <code>Array</code>. Dzięki temu każda nowo tworzona tablica posiada mnóstwo gotowych metod jak <code>map</code>, <code>filter</code>, <code>reduce</code> i tak dalej. Wszystkie one pochodzą właśnie z <code>Array.prototype</code> z podstawowego obiektu dla wszystkich tablic.</p><p>To właśnie dzięki prototypom, możemy od razu korzystać z gotowych funkcjonalności. Przeglądając <code>__proto__</code> dla naszej tablicy, zobaczymy, że <code>Array.prototype</code>, także ma swoje <code>__proto__</code>. Tym kolejnym <code>__proto__</code> jest <code>Object.prototype</code>.</p><p>Możemy się do tego prototypu odwołać tworząc taki łańcuch wywołań:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Object.prototype</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Na początku jest nasza tablica, potem jest <code>Array.prototype</code> i potem jest <code>Object.prototype</code>.</p><p>Możemy z ciekawości jeszcze raz odwołać się do <code>__proto__</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// null</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>otrzymamy wartość <code>null</code>. Łańcuch prototypów kiedyś się kończy i kończy się właśnie na <code>Object.prototype</code>. <code>Object.prototype</code> jest podstawowym prototypem dla wszystkich obiektów. Nie ważne czy to są nasze tworzone obiekty czy wbudowane jak <code>Array</code>, <code>String</code> czy <code>Boolean</code>. To zawsze od <code>Object.prototype</code> zaczyna się tworzenie podstaw obiektu, dlatego on zawsze znajdzie się na końcu łańcucha prototypów.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>każdy obiekt w JavaScript dziedziczy po <code>Object.prototype</code></li><li>każdy obiekt posiada wewnętrzną właściwość <code>[[Prototype]]</code> w której znajdują się odziedziczone właściwości prototypów innych obiektów</li><li>obiekty mają wewnętrzną właściwość <code>__proto__</code> ,która jest setterem i getterem dla <code>[[Prototype]]</code> obiektu</li><li>JavaScript ma wiele gotowych wbudowanych prototypów jak <code>String.prototype</code>, <code>Array.prototype</code> i inne</li><li>wbudowane prototypy wykorzystywane są przy tworzeniu obiektów danego typu i zapewniają szereg gotowych funkcjonalności</li></ul>',38),t={},s=(0,a(3744).Z)(t,[["render",function(o,e){return n}]])},3744:(o,e)=>{e.Z=(o,e)=>{for(const[a,n]of e)o[a]=n;return o}}}]);