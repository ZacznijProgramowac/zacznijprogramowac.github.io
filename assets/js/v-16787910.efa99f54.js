"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[8309],{8952:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-16787910",path:"/zmienne-i-typy/obiekty-wrappery/",title:"Obiekty opakowujące  - wrappery",lang:"pl-PL",frontmatter:{permalink:"/zmienne-i-typy/obiekty-wrappery"},excerpt:"",headers:[{level:2,title:"Tworzenie obiektu",slug:"tworzenie-obiektu",children:[]},{level:2,title:"Opakowanie wartości prymitywnej",slug:"opakowanie-wartosci-prymitywnej",children:[]},{level:2,title:"Konwersja za pomocą funkcji  Boolean(), Number() i String()",slug:"konwersja-za-pomoca-funkcji-boolean-number-i-string",children:[]},{level:2,title:"Prototype",slug:"prototype",children:[]},{level:2,title:"Inne objecty",slug:"inne-objecty",children:[]},{level:2,title:"Co warto zapamiętać:",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"zmienne-i-typy/09-obiekty-wrappery.md",git:{}}},5208:(n,a,s)=>{s.r(a),s.d(a,{default:()=>t});const e=(0,s(6252).uE)('<h1 id="obiekty-opakowujace-wrappery" tabindex="-1"><a class="header-anchor" href="#obiekty-opakowujace-wrappery" aria-hidden="true">#</a> Obiekty opakowujące - wrappery</h1><p>Do tej pory mówiliśmy głównie o trzech typach prymitywnych jak <code>boolean</code>, <code>number</code> czy <code>string</code>. Z tymi typami w JavaScript będziecie pracować na co dzień.</p><p>Od czasu do czasu zwracałem uwagę, że istnieją także obiekty zapisywane z dużej litery jak <code>Boolean</code>, <code>Number</code> i <code>String</code>. Często są to obiekty nazywane wraperami ponieważ ich głównym zadaniem jest opakowywanie wartości prymitywnej po to, abyśmy mogli na niej wywoływać metody.</p><p>Możemy je dodatkowo wykorzystać do konwersji czy też nadpisywania metod przez właściwość <code>prototype</code>. Omówimy sobie teraz po krótce sposoby działania tych mechanizmów.</p><h2 id="tworzenie-obiektu" tabindex="-1"><a class="header-anchor" href="#tworzenie-obiektu" aria-hidden="true">#</a> Tworzenie obiektu</h2><p>Kilka razy już zwracałem uwagę na możliwość tworzenia obiektu przez wywołanie konstruktora, stwórzmy sobie trzy takie obiekty i zobaczmy jak działają:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> bool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&#39;Lorem Ipsum&#39;</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [Boolean: true]</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [Number: 42]</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [String: &#39;Lorem Ipsum&#39;]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Obiekty te tworzymy przez wywołanie konstruktora ze słówkiem <code>new</code>. W ten sposób stworzymy obiekty, które będą w sobie przetrzymywały wartości prymitywne jak <code>boolean, number i string</code>, jednak same obiekty są typu ogólnego czyli <code>object</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> bool<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Oznacza to, że za każdym razem, gdy chcemy skorzystać z wartości prymitywnej musimy wywołać metodę <code>valueOf()</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;Lorem Ipsum&#39;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bool<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Tylko takim sposobem możemy pobrać wartość prymitywną z wartości obiektowej jak <code>Boolean, Number czy String</code>. Ponieważ są to typy <code>object</code> a nie wartości prymitywne, wiele zasad działania w porównaniu do typów prymitywnych, o których mówiliśmy nie działa.</p><p>Zainicjalizowany obiekt <code>Boolean</code> z wartością <code>false</code> i przekonwertowany na prymitywną wartość będzie zwracał <code>true</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Stringi nigdy nie będą sobie równe:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;test&#39;</span> <span class="token operator">===</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&#39;test&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>i to samo dotyczy obiektu <code>Number</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">42</span> <span class="token operator">===</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Dlatego używanie tych obiektów do inicjalizowania wartości wydaje się mało praktyczne i bardziej kłopotliwe. My głównie pracujemy na wartościach prymitywnych, natomiast obiekty <code>Boolean, Number i String</code> są głównie używane przez JavaScript. Ale przynajmniej teraz wiemy do czego służą.</p><h2 id="opakowanie-wartosci-prymitywnej" tabindex="-1"><a class="header-anchor" href="#opakowanie-wartosci-prymitywnej" aria-hidden="true">#</a> Opakowanie wartości prymitywnej</h2><p>Gdy zadeklarujemy wartości prymitywne w JavaScript, okazuje się, że możemy wywoływać na nich przeróżne metody.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> n <span class="token operator">=</span> <span class="token number">42.123456</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token string">&#39;Lorem Ipsum&#39;</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42.12</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;LOREM IPSUM&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Możemy na przykład wywołać <code>toString, toFixed, toUpperCase</code>. Metody te zależne są od typu z jakim pracujemy. Zdefiniowane są one w obiektach z dużej liter jak <code>Boolean, Number i String</code> jednak jest możliwość ich wywołania na typie prymitywnym.</p><p>Dzieje się tak, ponieważ JavaScript opakowuje wartości prymitywne w typ obiektowy. JavaScript robi to automatycznie gdy na wartości wywołujemy jedną z metod. Po zakończeniu działania metody, zwracana jest wartość prymitywna. Opakowanie to działa w tle i w pełni automatycznie, bez naszej większej kontroli. Dlatego mamy dostęp do wielu metod zadeklarowanych w typach obiektowych i możemy je wywołać na typie prymitywnym.</p><p>Jest to jedna z podstawowa funkcja tych obiektów w JavaScript.</p><h2 id="konwersja-za-pomoca-funkcji-boolean-number-i-string" tabindex="-1"><a class="header-anchor" href="#konwersja-za-pomoca-funkcji-boolean-number-i-string" aria-hidden="true">#</a> Konwersja za pomocą funkcji <code>Boolean(), Number() i String()</code></h2><p>Natomiast dobrym pomysłem jest używanie obiektów <code>Boolean, Number i String</code> jako funkcji, a więc bez wywołania konstruktora ze słówkiem <code>new</code>, oto przykłady takich działań:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> value1 <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">&#39;42.12&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> value2 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token number">42.12</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> value3 <span class="token operator">=</span> <span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">&#39;false&#39;</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;42&#39;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Wywołanie jako funkcja powoduje konwersję wartości na określony typ. Jest to jedna z najlepszych metod na konwersję, ponieważ działa bardzo precyzyjnie i samo wywołanie jest bardzo czytelne.</p><p>Właściwie do tego obiekty wrappery przydają się najbardziej, do konwersji wartości na określony typ.</p><p>Jeśli zastanawiacie się co z <code>null</code> i <code>undefined</code> te wartości prymitywne nie mają swojego obiektu opakowującego.</p><h2 id="prototype" tabindex="-1"><a class="header-anchor" href="#prototype" aria-hidden="true">#</a> Prototype</h2><p><code>Prototype</code> to mechanizm, za pomocą którego obiekty w JavaScript dziedziczą metody od siebie. Jeżeli zatem stworzymy sobie prymitywną wartość string i wywołamy metodę <code>toUpperCase()</code> to właśnie dzięki <code>prototype</code>.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> str1 <span class="token operator">=</span> <span class="token string">&#39;Lorem Ipsum&#39;</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  &#39;LOREM IPSUM&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Metoda ta dostępna jest w obiekcie <code>String</code> . Jeżeli wywołujemy na naszej wartości prymitywnej jakąś metodę, wartość ta jest opakowana w nowy obiekt <code>String</code>, który od razu ma w sobie gotowe metody zdefiniowane w globalnym obiekcie <code>String</code>. Każdy stworzony obiekt ma pakiet metod, które są dziedziczone.</p><p>Same obiekty jak <code>Boolean, Number i String</code> mogą także dziedziczyć metody z globalnego obiektu <code>Object</code>. Właśnie to zapewnia <code>prototype</code>, że tworzone obiekty dziedziczą po sobie metody, które są już zdefiniowane w JavaScript.</p><p>Metody <code>prototype </code> możemy też modyfikować:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toUpperCase</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&#39;Ha hahahaha&#39;</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  &#39;Ha hahahaha&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Jest to jednak słaby pomysł i raczej nie należy tego robić. Modyfikacja taka ma zasięg globalny. Możemy więc nadpisać metodę, która używana jest w wielu miejscach, co może doprowadzić do nieoczekiwanego działania.</p><p>Możemy także do <code>prototype</code> dopisać nowy obiekt:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&#39;This is my method&#39;</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Dodawanie nowej metody do <code>prototype</code> też nie jest za dobrym pomysłem. Możemy na przykład wejść w konflikt z inną biblioteką, która to robi. Dziś najczęściej <code>prototype</code> używa się przy polyfillingu. Czyli do wspierania nowych funkcjonalności języka JavaScript w przeglądarkach, które jeszcze nie wspierają najnowszych implementacji.</p><p>O <code>prototype</code> jeszcze porozmawiamy gdy zajmiemy się tworzeniem obiektów i klas w JavaScript. Teraz widzicie kolejny przykład, w którym można użyć obiektów jak <code>Boolean, Number i String</code>.</p><h2 id="inne-objecty" tabindex="-1"><a class="header-anchor" href="#inne-objecty" aria-hidden="true">#</a> Inne objecty</h2><p>W JavaScript występują także inne obiekty jak <code>Array, Object, Function, RegExp, Date</code> czy <code>Error</code>.</p><p>Zazwyczaj będziemy używać konstruktorów <code>new Date</code>, <code>new Error</code> i <code>new RegExp</code> do tworzenia obiektów za pomocą konstruktora.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">&#39;1 January 1970&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;Some error!&#39;</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> regExp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Jednak sam RegExp można zapisać w formie literałowej:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">abc</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Jeżeli wiemy z góry jaką postać będzie miało nasze wyrażenie regularne, dobrym pomysłem jest tworzenie formy literałowej. Taka forma jest kompilowana w czasie ładowania skryptu. Wpływa to na czytelność i wydajność.</p><p>Jeżeli jednak nasze wyrażenie regularne będzie musiało powstawać w dynamiczny sposób, jedynym wyjściem jest używanie wywołania z konstruktorem.</p><p>Nie ma natomiast potrzeb używania konstruktora dla obiektu <code>Object</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>używamy normalnej formy literałowej:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Również nie ma potrzebny definiowania funkcji za pomocą konstruktora:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> fun <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;param&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;return param + 100&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>chyba, że mamy potrzebę tworzenia funkcji w bardziej dynamiczny sposób. Zdarza się to niezwykle rzadko i zapis normalny jest wystarczający:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">fun1</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">param</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> param <span class="token operator">+</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Również unikamy tworzenia tablic za pomocą konstruktora Array:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>i stosujemy tradycyjny zapis literałowy:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Do funkcji, obiektów i tablic jeszcze wrócimy w naszym kursie. Warto jednak stosować się do tych zasad i upraszczać swój kod. Tworzenie obiektów zamiast wartości prymitywnych czy używanie konstruktorów do do funkcji, tablic czy obiektów jest niepotrzebną komplikacją i wielu przypadkach bardziej zaszkodzi niż pomoże. Działanie ich może być zupełnie różne. Bardzo często obiekty te wykorzystywane są przez mechanizmy JavaScript. W naszym kodzie zazwyczaj są zbędne.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać:</h2><ul><li>obiekty dla wartości prymitywnych używane są głównie przez silnik JavaScript do opakowania tych wartości</li><li>obiekty w JavaScript zapewniają wiele metod, które są dziedziczone przez <code>prototype</code></li><li>w nowoczesnym JavaScript unikamy nadpisywania czy dodawania metod przez <code>prototype</code></li><li>JavaScript ma wiele wbudowanych obiektów, które używa do swoich wewnętrznych mechanizmów</li><li>takich obiektów jak <code>Object</code>, <code>Array </code> czy <code>Function </code> nie powinniśmy używać z konstruktorem, chyba że mamy konkretne uzasadnienie i zapis literałowy nam nie wystarczy</li><li>Obiekty <code>Date</code> i <code>Error</code> używa się z konstruktorem, ponieważ nie mają zapisu literałowego</li></ul>',66),o={},t=(0,s(3744).Z)(o,[["render",function(n,a){return e}]])},3744:(n,a)=>{a.Z=(n,a)=>{for(const[s,e]of a)n[s]=e;return n}}}]);