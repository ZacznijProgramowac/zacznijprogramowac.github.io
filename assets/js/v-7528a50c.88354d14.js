"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[9221],{4368:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-7528a50c",path:"/funkcje/domkniecia-closures/",title:"Domknięcia - closures",lang:"pl-PL",frontmatter:{permalink:"/funkcje/domkniecia-closures/"},excerpt:"",headers:[{level:2,title:"Lexical scope i closure",slug:"lexical-scope-i-closure",children:[]},{level:2,title:"Zachowanie zakresu",slug:"zachowanie-zakresu",children:[]},{level:2,title:"Używanie closure",slug:"uzywanie-closure",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"funkcje/05-domkniecia-closures.md",git:{}}},4971:(n,a,s)=>{s.r(a),s.d(a,{default:()=>p});var e=s(6252);const o=(0,e.uE)('<h1 id="domkniecia-closures" tabindex="-1"><a class="header-anchor" href="#domkniecia-closures" aria-hidden="true">#</a> Domknięcia - closures</h1><p>Kolejnym zagadnieniem związanym z funkcjami są domknięcia po angielsku closures. Możecie być pewni, że na rozmowie o pracę będziecie o to zapytani. Gdy pada to pytanie, często trudno jest wytłumaczyć czym są domknięcia, a prawda jest taka że domknięcia używamy w kodzie nieustannie. Także pojawiły się wiele razy w tym kursie.</p><h1 id="lexical-scope-zakres-leksykalny" tabindex="-1"><a class="header-anchor" href="#lexical-scope-zakres-leksykalny" aria-hidden="true">#</a> Lexical scope. Zakres leksykalny</h1><p>Zanim przejdziemy do typowego przykładu domknięcia, warto jeszcze zaznajomić się z zakresem leksykalnym:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Widzimy w tym przypadku wywołanie funkcji <code>foo</code>. W środku funkcji zdefiniowana jest funkcja <code>bar</code>, która wyświetla zmienną <code>a</code> zdefiniowaną wyżej, wewnątrz funkcji otaczającej. Na końcu mamy wywołanie funkcji <code>bar</code>, która wypisuje wartość 42, po wywołaniu funkcji zewnętrznej <code>foo</code>.</p><p>Oznacza to, że wewnętrzna funkcja ma dostęp do wszystkich zakresów, które ją otaczają, również globalnego. Zakres jest jednak tworzony na podstawie deklaracji, a nie wywołania funkcji. Tutaj pojawia się właśnie zakres leksykalny, czyli lexical scope.</p><blockquote><p>Zakres leksykalny jest definiowany w miejscu deklarowania funkcji. Nie w miejscu jej wywołania.</p></blockquote><p>Ma to duże znaczenie, ponieważ od miejsca zadeklarowania funkcji, czyli jej zakresu leksykalnego będą poszukiwane zmienne, które ta funkcja używa. Oznacza to, że jeżeli teraz przeniesiemy wywołanie funkcji <code>bar</code> poza funkcję <code>foo</code> to i tak funkcja <code>bar</code> będzie miała dostęp do zmiennej <code>a</code>. Ponieważ jej zakresem leksykalnym jest miejsce jej położenia w kodzie. Ten mechanizm wykorzystuje closure.</p><p>Zwrócę jeszcze uwagę, że zakres leksykalny zależy tylko do nas, programistów. To my decydujemy w którym miejscu deklarujemy funkcję i decydujemy o jej zakresie leksykalnym.</p><h2 id="lexical-scope-i-closure" tabindex="-1"><a class="header-anchor" href="#lexical-scope-i-closure" aria-hidden="true">#</a> Lexical scope i closure</h2><p>Zobaczmy teraz przykład, gdzie idea zakresu leksykalnego będzie bardziej widzialna:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">function</span> <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> inner<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> innerFunction <span class="token operator">=</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>W tym przypadku mamy funkcję <code>outer</code>, która w środku definiuje funkcję <code>inner</code> i jej zadaniem jest wypisanie zmiennej <code>a</code>.</p><p>Na początku wywołujemy funkcję <code>outer</code> i przypisujemy do zmiennej <code>innerFunction</code>. Mamy więc w zmiennej <code>innerFunction</code> funkcję, która znajduje się w środku funkcji <code>outer</code>. Wykonujemy teraz funkcję <code>innerFunction</code> i otrzymujemy wartość <code>42</code>.</p><p>Wykonaliśmy funkcję <code>inner</code> w zakresie globalnym, gdzie także mamy zdefiniowaną zmienną <code>a</code> o wartości <code>0</code>. Widzimy jednak, że wykonana funkcja <code>inner</code> przypisana do zmiennej <code>innerFunction</code> i tak pobrała wartość z funkcji <code>outer</code>. Pomimo tego, że wykonywana jest w zakresie globalnym, to nadal ma dostęp do zakresu gdzie została zdefiniowana. I to jest właśnie lexical scope i clouser jednocześnie.</p><p>Closure, czyli domknięcie to mechanizm pozwalający funkcji na zachowanie dostępu do zakresu leksykalnego (czyli miejsca jej deklaracji), nawet gdy funkcja jest wykonywana poza tym zakresem.</p><p>O ile pierwszy przykład był bardziej rozwodniony i trudno było zobaczyć zakres leksykalny, bo wszystko działo się w jednej funkcji, to tym razem wyciągnęliśmy funkcję poza jej zakres i widzimy teraz działanie zakresu leksykalnego.</p><h2 id="zachowanie-zakresu" tabindex="-1"><a class="header-anchor" href="#zachowanie-zakresu" aria-hidden="true">#</a> Zachowanie zakresu</h2><p>Mogłoby się wydawać, że gdy zwrócimy funkcję z innej funkcji, to zewnętrzna funkcja jest całkowicie usuwana z pamięci. Zobaczmy taki przykład:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> add<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> increment <span class="token operator">=</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>\n<span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>\n<span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>Mamy zewnętrzną funkcję <code>counter</code>, która zwraca funkcję wewnętrzną <code>add</code>. Zadaniem tej funkcji jest zwiększanie wartości w zmiennej <code>a</code>. Gdy wywołamy funkcję <code>counter</code> i przypiszemy sobie funkcję <code>add</code> do zmiennej <code>increment</code> będziemy mogli wywołać ją kilka razy.</p><p>Wywołanie jej kilka razy powoduje zwiększanie wartości <code>a</code> w zewnętrznej funkcji. Oznacza to, że przy domknięciach, cały czas mamy dostęp do zakresu zewnętrznego tej funkcji. Nie działa więc mechanizm czyszczenia funkcji, który działa w przypadku normalnych funkcji. Zawsze bowiem po zakończeniu działania funkcji jest ona usuwana z pamięci.</p><p>Tutaj cały czas dostępny jest zakres zewnętrzny i jest wykorzystany do realizowania logiki aplikacji.</p><h2 id="uzywanie-closure" tabindex="-1"><a class="header-anchor" href="#uzywanie-closure" aria-hidden="true">#</a> Używanie closure</h2><p>Jeżeli teraz się zastanawiacie gdzie i jak używać domknięć i koniecznie chcecie mieć je w swoim kodzie to możecie być spokojni. Tak naprawdę domknięcia są przez Was używane niemalże codziennie, jeżeli piszecie kod w JavaScript. Są one bardzo naturalne i często połączone z funkcjami <code>callback</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">delay</span><span class="token punctuation">(</span><span class="token string">&#39;Closure!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Spójrzmy na taki przykład gdzie w funkcji <code>delay</code> definiujemy <code>setTimeout</code>. Funkcja <code>delay</code> posiada dodatkowo parametr <code>message</code>. Parametr ten jest przekazywany do funkcji callback w funkcji <code>setTimeout</code>. W ten sposób tworzymy domknięcie.</p><p>Inny przykład:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n  button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">++</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Funkcja, która przechowuje zmienną i zlicza kliknięcia na przycisku. Również mamy tutaj przykład funkcji <code>callback</code>, która tworzy domknięcie i korzysta ze zmiennej funkcji zewnętrznej.</p><p>Domknięcia w swoim kodzie znajdziecie w wielu miejscach, nie musimy się skupiać na tym, aby je używać, one są po prostu naturalnym sposobem pisania kodu w JavaScript.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>zakres leksykalny jest tam, gdzie zadeklarowana jest funkcja</li><li><code>closure</code> to możliwość wywołania funkcji poza jej zakresem leksykalnym, ale z zachowaniem dostępu do zakresu leksykalnego</li><li>w momencie wytworzenia domknięcia funkcja wewnętrzna ma dostęp do zakresów zewnętrznych, są one nadal utrzymywane w pamięci</li><li>nawet jeżeli nie znałeś pojęcia <code>closure </code> to i tak tworzyłeś kod, który wykorzystywał ten mechanizm</li></ul>',34),c={},p=(0,s(3744).Z)(c,[["render",function(n,a){const s=(0,e.up)("Comments");return(0,e.wg)(),(0,e.iD)(e.HY,null,[o,(0,e.Wm)(s)],64)}]])},3744:(n,a)=>{a.Z=(n,a)=>{for(const[s,e]of a)n[s]=e;return n}}}]);