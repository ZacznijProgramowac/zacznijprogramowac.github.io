"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[2045],{3688:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-edadd9d8",path:"/klasy/dziedziczenie/",title:"Dziedziczenie w JavaScript",lang:"pl-PL",frontmatter:{permalink:"/klasy/dziedziczenie"},excerpt:"",headers:[{level:2,title:"Dziedziczenie klas",slug:"dziedziczenie-klas",children:[]},{level:2,title:"Metoda super()",slug:"metoda-super",children:[]},{level:2,title:"Nadpisywanie metod",slug:"nadpisywanie-metod",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"klasy/03-dziedziczenie.md",git:{}}},1778:(n,a,s)=>{s.r(a),s.d(a,{default:()=>t});var e=s(6252);const o=(0,e.uE)('<h1 id="dziedziczenie-w-javascript" tabindex="-1"><a class="header-anchor" href="#dziedziczenie-w-javascript" aria-hidden="true">#</a> Dziedziczenie w JavaScript</h1><p>Wraz z ES6 w JavaScript dziedziczenie właściwości innych obiektów stało się łatwiejsze. Do tego czasu wykorzystywana była między innymi funkcja <code>Object.create</code> aby w jakiś sposób zaimplementować funkcjonalność, do której nie istniały tak proste narzędzia, jak klasy i słowo kluczowe <code>extends</code>.</p><h2 id="dziedziczenie-klas" tabindex="-1"><a class="header-anchor" href="#dziedziczenie-klas" aria-hidden="true">#</a> Dziedziczenie klas</h2><p>Jeśli chodzi o dziedziczenie, najlepiej od razu zacząć od przykładu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Na początek przygotowałem klasę bazową o nazwie <code>Animal</code>. Ma ona jedno pole o nazwie <code>name</code>. Ta klasa będzie bazą dla innych klas do tworzenia różnych typów zwierząt.</p><p>Przykładem jest klasa <code>Dog</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;How how!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token string">&#39;Reksio&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\ndog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Definicja klasy <code>Dof</code> używa słowa kluczowego <code>extends</code> i rozszerza klasę <code>Animal</code>. Oznacza to, że klasa <code>Dog</code> składa się teraz z tego, co znajduje się w <code>Animal</code> oraz z tego, co znajduje się w <code>Dog</code>. Czyli w skrócie możemy powiedzieć, że połączyłem dwie klasy w jedną.</p><p>Wiążą się z tym pewne zobowiązania. Przede wszystkim, nasz konstruktor także przyjmuje jakiś parametr, chociaż klasa <code>Dog</code> nie ma sama w sobie żadnego pola. Jednak takie pole istnieje w klasie <code>Animal</code> . Do konstruktora klasy <code>Animal</code>, odwołujemy się przez metodę <code>super()</code>, do której możemy przekazać parametr <code>name</code>. W ten sposób zainicjalizujemy to pole, które znajduje się w klasie nadrzędnej. Do samej metody <code>super()</code> jeszcze wrócimy, ponieważ jest tutaj więcej niuansów.</p><p>Widzimy, że stworzony obiekt <code>dog</code> ma dostęp do pola <code>name</code>, a także korzysta z własnej zdefiniowanej metody <code>bark</code>. Teraz moglibyśmy stworzyć kolejną klasę na przykład <code>Cat</code> z metodą <code>meow</code> i w ten sposób na bazie jednego typu <code>Animal</code>, możemy tworzyć kolejne typy zwierząt. Oczywiście po klasie <code>Animal</code>, możemy dziedziczyć nie tylko pola, ale także metody i metody statyczne.</p><p>To co się tutaj dzieje to tak naprawdę łączenie prototypów. Wiemy, że obiekt <code>dog</code> ma swój prototyp <code>Dog.prototype</code>. Ten prototyp ma wewnętrzną właściwość <code>[[Prototype]]</code>, do której dołączony jest <code>Animal.prototype</code> i na koniec jeszcze dołączony jest <code>Object.prototype</code>.</p><h2 id="metoda-super" tabindex="-1"><a class="header-anchor" href="#metoda-super" aria-hidden="true">#</a> Metoda <code>super()</code></h2><p>Metoda <code>super()</code> odwołuje się do klasy wyższego rzędu, czyli tej, którą rozszerzamy, wywołuje jej konstruktor:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">model</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>model <span class="token operator">=</span> model<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Audi</span> <span class="token keyword">extends</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> audi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Audi</span><span class="token punctuation">(</span><span class="token string">&#39;80&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>audi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Audi {model: &quot;80&quot;}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>W tym przykładowym kodzie mamy klasę <code>Car</code> z konstruktorem i polem <code>model</code>. Tworzymy inną klasę o nazwie <code>Audi</code> i rozszerzamy klasę <code>Car</code>. Nie używamy jednak konstruktora w klasie <code>Audi</code> i nie wywołujemy tym samym metody <code>super()</code>. Możemy jednak do konstruktora klasy <code>Audi</code> przekazać odpowiedni parametr, ponieważ konstruktor i tak będzie wywołany, a jeśli przekażemy parametry, to zostanie wywołany z parametrami. Również nastąpi niejawne wywołanie metody <code>super()</code> do której zostaną przekazane parametry.</p><p>Myślę, że czytelniej dla kodu jest stworzenie konstruktora z parametrami, gdy rozszerzamy jakąś klasę. Od razu wiemy, że powinniśmy zapewnić jakieś inicjalizacyjne dane.</p><p>Gdybyśmy jednak dodali konstruktor do klasy musielibyśmy od razu wywołać metodę <code>super</code>. Zawsze, gdy rozszerzamy jakąś klasę i mamy konstruktor, wywołanie metody <code>super</code> jest obowiązkowe. Jeżeli jednak nie stworzymy konstruktora to i tak po pierwsze JavaScript wywoła konstruktor sam oraz wywoła metodę <code>super</code>. Stanie się to niejawnie, ale i tak zostanie wywołane.</p><p>Przede wszystkim należy pamiętać, że rozszerzenie klasy i posiadanie konstruktora zmusza nas do wywołania metody <code>super()</code>, nawet gdy klasa nadrzędna sama nie ma konstruktora:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Soldier</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">weapon</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>weapon <span class="token operator">=</span> weapon<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> soldier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Soldier</span><span class="token punctuation">(</span><span class="token string">&#39;bow&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>W tym przykładzie mamy pustą klasę <code>Person</code>. Tworzę klasę <code>Soldier</code> i przez <code>extends</code> rozszerzam klasę <code>Person</code>. Jeżeli stworzyłem z jakichś powodów konstruktor w klasie <code>Soldier</code>, muszę wywołać metodę <code>super()</code> dla klasy nadrzędnej, nie jest istotne, że jest ona całkowicie pusta.</p><p>Dobrze, gdy metoda <code>super()</code> jest wywołana na początku konstruktora, a na pewno musi być wywołana przed odwołaniem się do <code>this</code>. Dlatego najczęściej jest ustawiana na samym początku, to zapewnia zawsze poprawne działanie.</p><p>Metoda <code>super()</code> może zostać wywołana tylko w konstruktorze, nie można jej wywołać w innej metodzie. Za chwilę się jednak przekonamy, że przez samą właściwość <code>super</code>, ale nie jako wywołanie metody, mamy dostęp do właściwości obiektu nadrzędnego i możemy wtedy używać <code>super</code> w innych metodach.</p><p>Metodę <code>super()</code> wywołujemy w konstruktorze tylko wtedy, gdy rozszerzamy jakąś klasę. Wywołanie jej w innym wypadku zgłosi błąd. To akurat będzie bardzo rzadki błąd, ale z doświadczenia wiem, że wiele osób zapomina w ogóle wywołać metodę <code>super()</code> gdy rozszerza jakąś klasę i jeszcze częściej przekazać przez tę metodę parametry do inicjalizacyjne dla konstruktora klasy nadrzędnej.</p><p>Gdy rozszerzamy inną klasę, musimy zawsze zwrócić szczególną uwagę na konstruktor klasy, którą będziemy rozszerzać i na parametry jakie przyjmuje. Jeżeli nie przekażemy odpowiednich parametrów spotkamy się z wartościami <code>undefined</code>.</p><h2 id="nadpisywanie-metod" tabindex="-1"><a class="header-anchor" href="#nadpisywanie-metod" aria-hidden="true">#</a> Nadpisywanie metod</h2><p>Czasami będziemy dziedziczyć po innych klasach różne metody, których funkcjonalność, nie zawsze musi nam pasować:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Document</span> <span class="token punctuation">{</span>\n  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Print document&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Email</span> <span class="token keyword">extends</span> <span class="token class-name">Document</span> <span class="token punctuation">{</span>\n  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Print to pdf&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> email <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Email</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nemail<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;Print to pdf&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>Mamy podstawową klasę <code>Document</code>, która ma zaimplementowaną metodę <code>print</code>. Metoda ta wykonuje normalne drukowanie dokumentu. Stworzona klasa <code>Email</code> rozszerza klasę <code>Document</code> i oczywiście dziedziczy metodę <code>print()</code>. Jednak gdy w klasie pochodnej, czyli w klasie <code>Email</code> zadeklarujemy metodę <code>print()</code> to przysłonimy tą metodę, która została odziedziczona. Od tego momentu będzie wywoływana metoda z klasy <code>Email</code> nie z klasy <code>Document</code>. W ten sposób nadpisujemy metody z klas nadrzędnych.</p><p>Nadpisywanie metod może się przydać, szczególnie gdy chcemy wcześniej wykonać inne czynności:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Image</span> <span class="token keyword">extends</span> <span class="token class-name">Document</span> <span class="token punctuation">{</span>\n  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;do some stuff&#39;</span><span class="token punctuation">)</span>\n    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> image <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nimage<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;do some stuff&#39;, </span>\n<span class="token comment">// &#39;Print document&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Mamy kolejną klasę <code>Image</code>, która rozszerza klasę <code>Document</code>. Tutaj także nadpisujemy metodę <code>print()</code>. Jednak w tej metodzie wykorzystujemy właściwość <code>super</code> i odwołujemy się jeszcze raz do metody <code>print()</code>, ale już z klasy nadrzędnej. Taki zapis oznacza odwołanie się do właściwości klasy nadrzędnej.</p><p>Mogliśmy więc nadpisać metodę, wykonać w niej dodatkowe czynności i na końcu wywołać metodę z klasy nadrzędnej. Można powiedzieć, że w ten sposób rozszerzyliśmy możliwości metody nadrzędnej, a nie tylko nadpisaliśmy ją.</p><p>Okazuje się więc, że definiując konstruktor w klasie pochodnej, tak naprawdę nadpisujemy konstruktor w klasie nadrzędnej, dlatego zawsze musimy wywołać <code>super()</code>, aby zainicjalizować konstruktor w klasie nadrzędnej. Różnica jest taka, że nadpisując konstruktor zawsze jesteśmy zobowiązani wywołać <code>super()</code> czego nie musimy robić przy zwykłych metodach.</p><p>Na koniec ważna uwaga, nie twórzmy metod jako <code>arrow function</code>, ponieważ nie posiadają one dostępu do <code>super</code>. W ogóle tworzenie metod jako <code>arrow function</code> w klasach jest złym pomysłem.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>do rozszerzania klas używamy słowa kluczowego <code>extends</code></li><li>dziedziczenie oznacza, że prototyp klasy nadrzędnej wstawiany jest do prototypu klasy pochodnej, czyli <code>Child.prototype.__proto__</code> będzie zawierało <code>Parent.prototype</code></li><li>gdy używamy konstruktora w klasie pochodnej musimy wywołać metodę <code>super()</code></li><li>metoda <code>super()</code> musi być wywołana przed jakimkolwiek <code>this</code>, dlatego najlepiej wywołać ją na początku konstruktora</li><li>możemy nadpisywać metody z klasy nadrzędnej</li><li>do metod z klasy nadrzędnej odwołujemy się przez <code>super.nazwaMetody</code></li><li>metody i pola statyczne również są dziedziczone</li></ul>',37),p={},t=(0,s(3744).Z)(p,[["render",function(n,a){const s=(0,e.up)("Comments");return(0,e.wg)(),(0,e.iD)(e.HY,null,[o,(0,e.Wm)(s)],64)}]])},3744:(n,a)=>{a.Z=(n,a)=>{for(const[s,e]of a)n[s]=e;return n}}}]);