"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[2906],{1067:(a,n,e)=>{e.r(n),e.d(n,{data:()=>s});const s={key:"v-1bcb951a",path:"/konwersje-i-porownania/konwersja-typow/",title:"Konwersja typów",lang:"pl-PL",frontmatter:{permalink:"/konwersje-i-porownania/konwersja-typow"},excerpt:"",headers:[{level:2,title:"Konwersja jawna",slug:"konwersja-jawna",children:[]},{level:2,title:"Konwersja niejawna",slug:"konwersja-niejawna",children:[]},{level:2,title:"Operator == i problemy",slug:"operator-i-problemy",children:[]},{level:2,title:"Porównanie null za pomocą ==",slug:"porownanie-null-za-pomoca",children:[]},{level:2,title:"Co warto zapamiętać:",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"konwersje-i-porownania/01-konwersja-typow.md",git:{}}},6666:(a,n,e)=>{e.r(n),e.d(n,{default:()=>t});var s=e(6252);const o=(0,s.uE)('<h1 id="konwersja-typow" tabindex="-1"><a class="header-anchor" href="#konwersja-typow" aria-hidden="true">#</a> Konwersja typów</h1><p>W JavaScript będziemy mieć bardzo często do czynienia z konwersją typów. Z konwersją będziemy spotykać się przy porównywaniu wartości, wykonywaniu działań matematycznych, konkatenacji ciągów znakowych czy nawet przy serializacji do formatu JSON.</p><p>Wielokrotnie sami będziemy decydowali o konwersji danych, będzie to wtedy konwersja jawna. Znacznie częściej jednak będzie odbywała się konwersja niejawna. Konwersja niejawna rządzi się wieloma regułami i zasadami. Zrozumienie ich może nam ułatwić pracę z JavaScript.</p><p>Nie ważne, która z nich występuje, każda konwersja w JavaScript to konwersja tylko do typu prymitywnego. W wyniku konwersji otrzymamy zawsze wartość typu <code>boolean</code>, <code>string</code> albo <code>number</code>.</p><div class="language-JS ext-JS line-numbers-mode"><pre class="language-JS"><code>// boolean, string, number\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Dodatkowo konwersja dla typów prymitywnych i obiektowych różnią się. W tym dziale zajmiemy się typami prymitywnymi. Gdy będziemy omawiać obiekty, wrócimy jeszcze do konwersji i tego jak one zachowują się gdy musi nastąpić ich konwersja do typu prymitywnego.</p><h2 id="konwersja-jawna" tabindex="-1"><a class="header-anchor" href="#konwersja-jawna" aria-hidden="true">#</a> Konwersja jawna</h2><p>Jeśli chodzi o konwersję jawną to dzieje się wtedy, kiedy w kodzie zastosujemy konkretną instrukcję. Dobrym przykładem jest wykorzystanie funkcji <code>Boolean(), String() i Number()</code>.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">&#39;false&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;42&#39;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">&#39;42.12&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42.12</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Ten zapis mówi nam dokładnie o tym, że wartości zostaną przekonwertowane na odpowiednie typy.</p><p>Jeżeli podamy do tych funkcji poprawne formy danych, otrzymamy spodziewany wynik. Każdą z tych funkcji omówimy jeszcze dokładnie w dalszej części działu.</p><h2 id="konwersja-niejawna" tabindex="-1"><a class="header-anchor" href="#konwersja-niejawna" aria-hidden="true">#</a> Konwersja niejawna</h2><p>W JavaScript częściej będziemy mieli jednak do czynienia z niejawną konwersją, która często zaskakuje programistów swoimi wynikami. Niejawna konwersja bardzo często stosowana jest przy wszelkich porównaniach, instrukcjach warunkowych. Często wynikiem niejawnej konwersji jest typ <code>boolean</code>.</p><p>Jeden z popularniejszych przypadków w kodzie to sprawdzenie, czy zmienna ma jakąś wartość:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token string">&#39;false&#39;</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>W tym przypadku zmienna <code>a</code> reprezentuje typ <code>string</code>. Ten łańcuch znaków nie jest pusty, a niepusty <code>string</code> konwertowany jest na wartość <code>true</code>. Ostatecznie więc zmienna <code>a</code> na potrzeby instrukcji warunkowej <code>if</code> zostaje niejawnie skonwertowana do typu <code>boolean</code> o wartości <code>true</code>.</p><p>Zobaczmy kolejny przypadek:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token string">&#39; &#39;</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Tutaj również sprawdzamy, czy zmienna <code>b</code> ma jakąś wartość. Na pierwszy rzut oka wydaje nam się, że nie. Jednak spacja to także wartość w JavaScript i choć mogłoby się wydawać, że nic tam nie ma, nastąpi niejawna konwersja do typu <code>boolean</code> i będzie ona miała wartość <code>true</code>.</p><p>Kolejnym przypadkiem niejawnej konwersji jest dodanie pustego stringa:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token number">42</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">// &#39;42&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Tak naprawdę jest to operacja dodawania. Jednak gdy jedna ze stron reprezentuje typ <code>string</code> następuje konwersja drugiej strony do typu <code>string</code>. Dlatego też ostatecznie otrzymujemy liczbę zapisaną jako <code>string</code>.</p><h2 id="operator-i-problemy" tabindex="-1"><a class="header-anchor" href="#operator-i-problemy" aria-hidden="true">#</a> Operator <code>==</code> i problemy</h2><p>Szczególnie dużo niejawnych konwersji zachodzi przy operatorach porównania, arytmetycznych i logicznych. Cały system konwersji w JavaScript jest bardzo rozbudowany i ma swoje konkretne zasady.</p><p>Szczególny problem powoduje operator podwójnego porównania <code>==</code> . Zapamiętanie wszystkich możliwych wyników, jakie daje ten operator, nie jest możliwe.</p><p>Dlatego tak często operator ten zaskakuje programistów, a używanie go dzisiaj to proszenie się o problemy. Jednak nadal operator ten istnieje w JavaScript, jest też częstym elementem dyskusji na rozmowie o pracę i warto o nim wiedzieć coś więcej.</p><p>Rozważmy taki przypadek, z którego otrzymujemy wartość <code>false</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">==</span> <span class="token string">&#39;true&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Porównujemy wartość <code>true</code> z napisem <code>&#39;true&#39;</code>. Moglibyśmy wydedukować, że jeżeli po lewej jest wartość <code>boolean</code> to wartość po prawej stronie będzie przekonwertowana do wartości <code>true</code> w typie boolean.</p><p>Niestety, przy porównaniach, działają zupełnie inne zasady i możemy je przejrzeć w specyfikacji ECMAScript https://www.ecma-international.org/ecma-262/5.1/#sec-11.9</p><p>Gdy przeanalizujemy nasze porównanie zgodnie z tym, co jest w specyfikacji, zobaczymy zapis, że:</p><blockquote><p>If Type(<em>x</em>) is Boolean, return the result of the comparison ToNumber(<em>x</em>) == <em>y</em>.</p></blockquote><p>Jeżeli pierwszą wartością jest <code>boolean</code> to następuje niejawna konwersja <code>boolean</code> na <code>number</code>.</p><p>Po pierwszej niejawnej konwersji porównanie zmienia się na taką postać:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token string">&#39;true&#39;</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>w specyfikacji czytamy dalej:</p><blockquote><p>If Type(<em>x</em>) is Number and Type(<em>y</em>) is String, return the result of the comparison <em>x</em> == ToNumber(<em>y</em>).</p></blockquote><p>Jeżeli teraz pierwszą wartością jest <code>number</code> a drugą wartością <code>string</code> to należy przekonwertować drugą wartość na <code>number</code>. Nasze porównanie więc znowu zmienia postać taką:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">&#39;true&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NaN</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">NaN</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Wszystko zostało sprowadzone do typu <code>number</code> i na końcu sprawdzane jest, czy liczba jeden równa się <code>NaN</code>. Pamiętajmy, że w JavaScript <code>NaN</code> to <code>number</code>, są to więc dwie różne liczby. Otrzymujemy więc wartość <code>false</code>, pomimo, że mogliśmy się spodziewać wartości <code>true</code>. Przeszliśmy przez szereg niejawnych konwersji, a wynik dla nas nie był oczywisty.</p><p>Spamiętanie tego jest bardzo trudne. W Internecie znajdziecie świetną stronę, autorstwa użytkownika <em>Dorey</em> która pokazuje przypadki konwersji przy porównaniu, a także konwersję przy instrukcji <code>if</code> https://dorey.github.io/JavaScript-Equality-Table/</p><p><img src="/images/table1.png" alt="table1"></p><p>Tabela prezentujące możliwe wyniki przy operatorze podwójnego porównania jest trudna do zapamiętania i nawet nie należy próbować jej zapamiętać.</p><p>Wniosek z tych wszystkich materiałów jest zawsze taki, że najlepiej używać potrójnego operatora porównania. Który nie dokonuje konwersji. Prezentuje to już druga tabelka:</p><p><img src="/images/table2.png" alt="table2"></p><p>Zadaniem potrójnego operatora jest sprawdzenie, czy wartości są takie same i mają ten sam typ. Nie zachodzą żadne niejawne konwersje, a tabelka w odczytaniu jest już bardzo prosta. Otrzymujemy <code>true</code> tylko tam, gdzie w porównaniu mamy dokładnie ten sam typ i tę samą wartość.</p><p>Wróćmy jeszcze na chwilę do naszego przykładu.</p><p>Może nam bardzo zależeć na porównaniu takich wartościach jak <code>boolean</code> i <code>string</code>, Jeżeli chcemy to koniecznie zrobić najlepiej zastosować jawną konwersję do typu <code>boolean</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">===</span> <span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">&#39;true&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Dokonując konwersji jawnej i stosując potrójny operatora porównania, kod mamy pod większą kontrolą i nie jesteśmy zdani na wynik niejawnej konwersji, który jest trudny do przewidzenia. Tym sposobem unikniemy wielu problemów.</p><h2 id="porownanie-null-za-pomoca" tabindex="-1"><a class="header-anchor" href="#porownanie-null-za-pomoca" aria-hidden="true">#</a> Porównanie null za pomocą ==</h2><p>Czasami możecie jednak zobaczyć w użyciu podwójne porównanie. Jedynym przypadkiem, w którym podwójny operator sprawdza się to porównanie do wartości <code>null</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> z <span class="token operator">=</span> <span class="token string">&#39;test&#39;</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>z <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Ten zwięzły zapis pozwala sprawdzić, czy wartość nie jest <code>null</code> lub <code>undefined</code>.</p><p>Nie wiem jednak, czy robienie w kodzie wyjątku na takie podwójne porównanie przyniesie Wam wiele korzyści. Osobiście z podwójnego operatora porównania zrezygnowałbym całkowicie. Choćby dla ujednolicenia zasad w kodzie.</p><p>Dalszymi przypadkami konwersji zajmiemy się w kolejnych filmach, gdzie poznamy operatory porównania, operatory logicznego porównania i różne sposoby jawnej i niejawnej konwersji.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać:</h2><ul><li>w JavaScript mamy konwersję jawną i niejawną</li><li>każda konwersja to sprowadzanie do wartości prymitywnej</li><li>operatory często stosują niejawną konwersję, operator podwójnego porównania jest szczególnie trudny do rozszyfrowania</li><li>w Internecie mamy dostęp do tabel, które pokazują konkretne przypadki porównania</li><li>jeżeli używamy operatora porównania to tylko potrójnego</li></ul>',58),p={},t=(0,e(3744).Z)(p,[["render",function(a,n){const e=(0,s.up)("Comments");return(0,s.wg)(),(0,s.iD)(s.HY,null,[o,(0,s.Wm)(e)],64)}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[e,s]of n)a[e]=s;return a}}}]);