"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[2785],{910:(a,n,s)=>{s.r(n),s.d(n,{data:()=>e});const e={key:"v-d32ad910",path:"/instrukcje-warunkowe/optional-chaining-operator/",title:"Optional Chaining Operator",lang:"pl-PL",frontmatter:{permalink:"/instrukcje-warunkowe/optional-chaining-operator/"},excerpt:"",headers:[{level:2,title:"Wywołanie funkcji",slug:"wywołanie-funkcji",children:[]},{level:2,title:"Wykorzystanie przy tablicach",slug:"wykorzystanie-przy-tablicach",children:[]},{level:2,title:"Połączenie z operatorem nullowym",slug:"połaczenie-z-operatorem-nullowym",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"instrukcje-warunkowe/05-optional-chaining-operator.md",git:{}}},6947:(a,n,s)=>{s.r(n),s.d(n,{default:()=>t});var e=s(6252);const o=(0,e.uE)('<h1 id="optional-chaining-operator" tabindex="-1"><a class="header-anchor" href="#optional-chaining-operator" aria-hidden="true">#</a> Optional Chaining Operator</h1><p>W ESCMAScript 2020 pojawia się kolejny nowy operator o nazwie Optional Chaining. Jeżeli chcemy go używać, warto sprawdzić, czy jest już zaimplementowany w przeglądarkach, które będziemy wspierać. W innym wypadku należy użyć skryptów .</p><p>Operator ten reprezentowany jest przez znak zapytania i kropki <code>?.</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  person<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>person<span class="token operator">?.</span>name<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Za jego pomocą możemy wykonać proste sprawdzenie, czy kolejne właściwości obiektu istnieją, zanim nastąpi próba ich odczytania. Widzimy w tym przypadku, że zanim odwołam się do pola <code>name</code> to operator sprawdza wcześniej, czy obiekt <code>person</code> istnieje. Jeżeli właściwość, do której się odwołujemy nie istnieje to zwracana jest wartość <code>undefined</code> i nie zostanie zwrócony błąd przez JavaScript.</p><p>Obiekt person nie musi być też koniecznie obiektem o wartości nullowej:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  person<span class="token operator">:</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>person<span class="token operator">?.</span>name<span class="token punctuation">)</span> <span class="token comment">// undefined</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Optional Chaining sprawdza po kolei ścieżkę odwołania i jeżeli nie uda mu się pobrać kolejnego odwołania, zwracana jest wartość <code>undefined</code>. Dla tego operatora nie ma znaczenia, do jakich pól się odwołujemy, operator ten sprawdza czy możliwy jest łańcuch wywołania, który zapisaliśmy w wyrażeniu.</p><p>Gdybyśmy chcieli zrobić to w tradycyjny sposób, użylibyśmy na przykład operatora AND:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>person <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">.</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// null</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Optional Chaining ma zdecydowaną przewagę, zapewniając prosty i czytelny kod.</p><p>Możemy sobie dodatkowo wyobrazić, że pracujemy z obiektami z jakiegoś zewnętrznego API i nigdy nie wiadomo co do nas przyjdzie, a obiekty takie zazwyczaj są mocno zagnieżdżone w sobie:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>response <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> res <span class="token operator">=</span> response<span class="token punctuation">.</span>data<span class="token operator">?.</span>user<span class="token operator">?.</span>adress<span class="token operator">?.</span>postcode\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Czasami musimy sprawdzić dosłownie każdą właściwość obiektu, zanim pobierzemy z niej jakaś wartość. Z tym operatorem robimy to w bardzo eleganckiej formie. Już pozostawiam Wam wyobrażenie sobie, jak wiele warunków trzeba by sprawdzić z operatorem AND.</p><h2 id="wywołanie-funkcji" tabindex="-1"><a class="header-anchor" href="#wywołanie-funkcji" aria-hidden="true">#</a> Wywołanie funkcji</h2><p>Operator ten możemy także użyć w przypadku wywołania funkcji:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>getName<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Mamy obiekt person, który ma zdefiniowane pole <code>name</code>, nie ma w nim jednak funkcji <code>getName()</code>. Możemy więc przed wywołaniem funkcji użyć operatora Optional Chaining. Widzimy, że między nazwą funkcji a nawiasami wstawiamy operator.</p><p>Bardzo fajne zastosowanie tego operatora można znaleźć przy funkcjach callback:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token parameter">printer<span class="token punctuation">,</span> error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token function">printer</span><span class="token punctuation">(</span><span class="token string">&#39;Print&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    error<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token string">&#39;Some error&#39;</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">print</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span> <span class="token comment">// &#39;Print&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Mamy funkcję <code>print</code>, do której mogę przekazać inną funkcję, która będzie wypisywała tekst do konsoli. Funkcja <code>print</code> wyłapuje też możliwość wystąpienia błędu, na przykład, jeśli nie przekażemy do funkcji <code>print</code> żadnego callbacka. Teraz przekazaliśmy funkcję <code>console.log</code> jako callback i wszystko działa ok.</p><p>Jednak przy takim wywołaniu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>W bloku <code>try</code> wystąpi błąd, który będzie obsłużony w bloku <code>catch</code>, tam powinna zostać wywołana funkcja <code>error</code>, jednak funkcja <code>error</code>, nie została przekazana. Normalnie JavaScript zgłosiłby kolejny błąd, że próbujemy wywołać funkcję, która jest <code>undefined</code>. Operator Optional Chaining pozwala nam zabezpieczyć się przed wywołaniem funkcji, która może nie istnieć.</p><h2 id="wykorzystanie-przy-tablicach" tabindex="-1"><a class="header-anchor" href="#wykorzystanie-przy-tablicach" aria-hidden="true">#</a> Wykorzystanie przy tablicach</h2><p>Operator ten może być również użyty przy tablicach:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array<span class="token operator">?.</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Mamy obiekt <code>array</code>, który ma wartość <code>undefined</code>, ale jego nazwa sugeruje, że jest to tablica. Próba pobrania jakiegoś elementu za pomocą indeksu skończy się błędem zgłoszonym przez JavaScript. Za pomocą operatora Optional Chaining możemy uniknąć błędu i otrzymać wartość <code>undefined</code>.</p><h2 id="połaczenie-z-operatorem-nullowym" tabindex="-1"><a class="header-anchor" href="#połaczenie-z-operatorem-nullowym" aria-hidden="true">#</a> Połączenie z operatorem nullowym</h2><p>Operator Optional Chaining świetnie nadaje się do połączenia go z operatorem nullowym:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&quot;Carl&quot;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token operator">?.</span>address <span class="token operator">??</span> <span class="token string">&quot;Unknown address&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;Unknown address&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Mamy obiekt <code>user</code>, który posiada tylko właściwość <code>name</code>. My natomiast próbujemy znaleźć właściwość <code>address</code>. Jeżeli jej nie będzie to zwrócimy wartość domyślną <code>Unknow address</code>. Tutaj świetną synergię robią te dwa operatory.</p><p>Gdybym chciał to zapisać bez operatorów:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> address <span class="token operator">=</span> user <span class="token operator">&amp;&amp;</span> user<span class="token punctuation">.</span>address <span class="token operator">?</span> user<span class="token punctuation">.</span>address <span class="token operator">:</span> <span class="token string">&quot;Unknown address&quot;</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token comment">// &#39;Unknown address&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>W moim rozwiązaniu łączę operator <code>AND</code> oraz ternary operator. Cały zapis wygląda na bardziej rozwlekły i skomplikowany.</p><p>Operator Optional Chaining ma bardzo duże możliwości i na pewno nie wykorzystaliśmy jego całego potencjału. Wszędzie tam, gdzie będziecie pracować z niepewnymi danymi jak obiekty o nieznanej strukturze, operator ten będzie bardzo przydatny.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>operator Optional Chaining reprezentowany jest przez <code>?.</code> znak zapytania i kropkę</li><li>operator ten chroni nas przed wywołaniem lub odczytaniem właściwości, która nie istnieje</li><li>operator ten możemy użyć przy dostępnie do pól obiektu, dostępie do danych w tablicach czy przy wywołaniu funkcji</li><li>w prosty sposób może nam zastąpić operator <code>AND</code></li></ul>',38),p={},t=(0,s(3744).Z)(p,[["render",function(a,n){const s=(0,e.up)("Comments");return(0,e.wg)(),(0,e.iD)(e.HY,null,[o,(0,e.Wm)(s)],64)}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[s,e]of n)a[s]=e;return a}}}]);