"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[7712],{4216:(n,a,e)=>{e.r(a),e.d(a,{data:()=>o});const o={key:"v-01abb096",path:"/zmienne-i-typy/typ-boolean/",title:"Typ boolean - typ logiczny",lang:"pl-PL",frontmatter:{permalink:"/zmienne-i-typy/typ-boolean"},excerpt:"",headers:[{level:2,title:"Wartość typu boolean",slug:"wartosc-typu-boolean",children:[]},{level:2,title:'Wartość "false", "true" to nie boolean',slug:"wartosc-false-true-to-nie-boolean",children:[]},{level:2,title:"Wartość 0 i 1 nie reprezentują typu boolean",slug:"wartosc-0-i-1-nie-reprezentuja-typu-boolean",children:[]},{level:2,title:"Obiekt Boolean i funkcja Boolean()",slug:"obiekt-boolean-i-funkcja-boolean",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"zmienne-i-typy/04-typ-boolean.md",git:{}}},1318:(n,a,e)=>{e.r(a),e.d(a,{default:()=>t});const o=(0,e(6252).uE)('<h1 id="typ-boolean-typ-logiczny" tabindex="-1"><a class="header-anchor" href="#typ-boolean-typ-logiczny" aria-hidden="true">#</a> Typ boolean - typ logiczny</h1><p>Przed nami omówienie typu boolean. Jest to typ, który występuje niezwykle często w języku JavaScript, przeważnie po niejawnych konwersjach. Dowiedzmy się jak rozpoznać co będzie <code>true</code>, a co <code>false</code> w naszej aplikacji.</p><h2 id="wartosc-typu-boolean" tabindex="-1"><a class="header-anchor" href="#wartosc-typu-boolean" aria-hidden="true">#</a> Wartość typu boolean</h2><p>Typ logiczny <code>boolean</code>, jest używany do sprawdzania wszelkich warunków, ustawiania flag czy stanów aplikacji. Typ <code>boolean</code> jest na pewno znany każdemu kto uczył się lub zna jakikolwiek język programowania.</p><p>Jest to typ który może posiadać tylko dwie wartości:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token boolean">true</span> <span class="token boolean">false</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Poprzedni typ <code>undefined</code> posiadał jedną wartość <code>undefined</code>, a <code>null</code> który był niestety typem <code>object</code> posiadał jedną wartość <code>null</code>. W tym przypadku mamy już typ, który może mieć dwie wartości.</p><p>Utwórzmy dwie zmienne, które będą przechowywały wartość <code>true</code> i wartość <code>false</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> isDone <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> isAdult <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>wypiszę teraz obie zmienne za pomocą <code>console.log</code> i sprawdzę także ich typy:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isDone<span class="token punctuation">,</span> <span class="token keyword">typeof</span> isDone<span class="token punctuation">)</span> <span class="token comment">// false boolean</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isAdult<span class="token punctuation">,</span> <span class="token keyword">typeof</span> isAdult<span class="token punctuation">)</span> <span class="token comment">// true boolean</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>W konsoli zobaczymy wartość <code>false</code> i typ <code>boolean</code> oraz wartość <code>true</code> i typ <code>boolean</code>. Tym razem JavaScript (na razie) nas niczym nie zaskakuje.</p><p>Przy okazji zwrócę uwagę na <code>console.log</code> do którego po przecinku przekazałem więcej niż jeden argument. Jest to zapis, który pozwala wypisać nam jednocześnie więcej wartości. Możemy tam przekazać dowolną liczbę argumentów.</p><h2 id="wartosc-false-true-to-nie-boolean" tabindex="-1"><a class="header-anchor" href="#wartosc-false-true-to-nie-boolean" aria-hidden="true">#</a> Wartość &quot;false&quot;, &quot;true&quot; to nie boolean</h2><p>Jeżeli spotkacie się z zapisem wartości <code>false</code> lub <code>true</code> w cudzysłowach, to musicie pamiętać, że nie jest to wartość <code>boolean</code>. Zobaczmy taki przykład gdzie mam zadeklarowaną zmienną <code>isOpen</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> isOpen <span class="token operator">=</span> <span class="token string">&#39;false&#39;</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> isOpen<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Do zmiennej <code>isOpen</code> mam przypisaną wartość <code>&#39;false&#39;</code>, ale jako tekst, czyli jest to typ <code>string</code>. Nie ma to nic wspólnego z typem <code>boolean</code>.</p><p>Jeszcze bardziej możecie być zdziwieni, gdy przekonwertuję tego stringa na wartość <code>boolean</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span>isOpen<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Konwersja na typ <code>boolean</code> napisu <code>&#39;false&#39;</code>, zwraca <code>true</code>. I oczywiście działa to prawidłowo, mówiliśmy już o specyfikacji ECMAScript, w której umieszczone są informacje jakie wartości konwertowane są do <code>false</code>.</p><p>https://developer.mozilla.org/en-US/docs/Glossary/Falsy</p><p>Przypominam jeszcze raz tą rozpiskę:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">0n</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Jak widzimy, tylko pusty string <code>&#39;&#39;</code> jest konwertowany do wartości <code>false</code>. Tak więc, napis <code>&#39;false&#39;</code> konwertowany do typu <code>boolean</code> będzie miał wartość <code>true</code> ponieważ nie jest pustym stringiem.</p><p>Mówię o tym tyle, ponieważ jest to częsta zagwozdka początkujących programistów JavaScript. Często też, możecie być o to zapytani na rozmowie rekrutacyjnej.</p><p>Należy zapamiętać, że napis <code>&#39;true&#39;</code> i <code>&#39;false&#39;</code> to jest typ <code>string</code> a nie <code>boolean</code>. Nie ma to nic wspólnego z wartościami <code>true</code> i <code>false</code>, które są typu <code>boolean</code>.</p><p>Niepusty string konwertowany do <code>boolean</code>, da nam zawsze wartość <code>true</code>. Ponieważ każdy niepusty string konwertowany jest do wartości <code>true</code>, a tylko pusty string konwertowany jest do wartości <code>false</code>.</p><h2 id="wartosc-0-i-1-nie-reprezentuja-typu-boolean" tabindex="-1"><a class="header-anchor" href="#wartosc-0-i-1-nie-reprezentuja-typu-boolean" aria-hidden="true">#</a> Wartość 0 i 1 nie reprezentują typu <code>boolean</code></h2><p>Będąc przy tym problemie warto jeszcze wspomnieć o wartości <code>1</code> i <code>0</code>. Również często możecie zostać zapytani o to na rozmowie o pracę. Wartość <code>1</code> i <code>0</code> nie reprezentują typu <code>boolean</code>. Wartości te reprezentują typ <code>number</code>. Niestety jest mylne przekonanie, że te wartości reprezentują kolejno <code>true</code> i <code>false</code>.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Wartość <code>0</code> zawsze będzie konwertowana do wartości <code>false</code>, bo tak wynika ze z listy wartości fałszywych, wartość <code>1</code> zawsze będzie konwertowana do wartości <code>true</code>, bo nie ma jej w naszej liście wartości fałszywych.</p><p>Często też kod JavaScript opiera się na wartościach <code>1</code> i <code>0</code> do sprawdzenia czy coś jest <code>true</code> lub <code>false</code>. Przykładem może być sprawdzenie długości listy:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Do something&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Gdy lista jest pusta, właściwość <code>lenght</code> zwraca <code>0</code> co jest konwertowane do wartości <code>false</code>. Gdy lista ma jakieś elementy, zwróci konkretną liczbę tych elementów. Może być to wartość <code>1</code>, <code>2</code> a nawet <code>10</code> i będzie to konwertowane do <code>true</code>. Ponieważ każda liczba prócz <code>0</code> jest konwertowana do <code>true</code>. Znowu dotykamy tutaj tematu niejawnej konwersji, który jeszcze będziemy poruszać.</p><h2 id="obiekt-boolean-i-funkcja-boolean" tabindex="-1"><a class="header-anchor" href="#obiekt-boolean-i-funkcja-boolean" aria-hidden="true">#</a> Obiekt Boolean i funkcja Boolean()</h2><p>O konwersji typów i jej zawiłościach będziemy jeszcze mówić w oddzielnych odcinkach. Również o obiekcie <code>Boolean</code> zapisywanym z dużej litery. Jak się potem okaże, prawie każdy typ ma taki obiekt zapisywany z dużej litery. Obiekty te nazywane są wraperami.</p><p>Ja do tej pory używałem funkcji <code>Boolean()</code> do konwertowania różnych typów na prostą wartość <code>boolean</code>. I od razu powiem, że funkcji <code>Boolean()</code> najlepiej używać tylko do konwersji. Będąc już przy dużym <code>Boolean</code> warto zwrócić uwagę na jedną bardzo ważną rzecz.</p><p>Gdy używamy obiektu <code>Boolean</code> ma znaczenie czy użyjemy go ze słowem kluczowym <code>new</code> czy bez.</p><p>Wywołanie ze słowem kluczowym <code>new</code>, zainicjalizuje nowy typ obiektowy:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> bObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [Boolean: false] object</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Wywołanie <code>Boolean() </code> tylko z nawiasami okrągłymi już bez słowa <code>new</code> jest traktowane jako wywołanie funkcji:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> bConverted <span class="token operator">=</span> <span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>w taki sposób właśnie robimy konwersję do typu prostego <code>boolean</code>. Używając słowa kluczowego <code>new</code> stworzymy nowy obiekt. Jest to ważna różnica, która dotyczy nie tylko obiektu <code>Boolean</code>, ale także pozostałych jak <code>String</code> czy <code>Number</code>, które jeszcze poznamy.</p><p>Oto przykład, dlaczego nie warto używać <code>new Boolean</code> do inicjalizowania zmiennej:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token keyword">typeof</span> a<span class="token punctuation">)</span> <span class="token comment">// [Boolean: false] object</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Zainicjalizowałem zmienną <code>a</code> obiektem <code>new Boolean</code>, gdy wypiszemy zmienną <code>a</code> do konsoli zobaczymy obiekt z wartością <code>false</code>. Zwracam szczególną uwagę, że jest to <code>object</code>, nie wartość prymitywna <code>boolean</code>.</p><p>Co się stanie gdy stworzymy teraz blok <code>if</code> i spróbujemy sprawdzić zmienną <code>a</code>. Blok <code>if</code> zadziała gdy <code>a</code> ma wartość <code>true</code> i wtedy do konsoli wypisze tekst:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;It works, why?&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Okazuje się, że zobaczymy w konsoli napis, a przecież zainicjalizowaliśmy zmienną <code>a</code> obiektem <code>Boolean</code> z wartością <code>fasle</code>. I tutaj jest cały problem, że <code>a</code> jest obiektem, nie wartością prymitywną. Konwertowany obiekt do wartości <code>boolean</code> będzie zwracał zawsze <code>true</code>, nie ważne czy obiekt jest pusty czy ma swoje właściwości.</p><p>Przykładem jest ta konwersja pustego obiektu za pomocą <code>Boolean()</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Obiekt konwertowany do wartości <code>boolean</code> zwraca zawsze <code>true</code>. Nie ma go na rozpisce wartości fałszywych. Jeżeli czegoś nie ma na liście wartości fałszywych, to zawsze otrzymujemy <code>true</code>. Dla JavaScript nie ma znaczenia, że my tworzymy obiekt <code>Boolean</code> i inicjalizujemy go wartością <code>fasle</code>. JavaScript zmienną <code>a</code> rozpatruje po prostu jako typ <code>object</code>, a nie <code>boolean</code>.</p><p>Gdy już posługujemy się obiektem <code>new Boolean</code> zamiast wartością prymitywną, nasz zapis powinien wyglądać tak:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Now, it does not work&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>wywołujemy metodę <code>valueOf()</code>, która zwróci nam wartość prymitywną <code>boolean</code> z obiektu stworzonego za pomocą <code>new Boolean</code>. Dopiero nasz kod działa zgodnie z założeniem. Widzicie sami jak wiele komplikacji wprowadza typ obiektowy <code>new Boolean</code>.</p><p>Dlaczego one istnieją i do czego są potrzebne powiemy sobie w oddzielnym odcinku. Główną naszą zasadą powinno być używanie tylko wartości prymitywnej <code>boolean</code>. Natomiast samo wywołanie obiektu <code>Boolean()</code> jako funkcji możemy z powodzeniem używać do konwertowania wartości na typ prymitywny <code>boolean</code>. Trudno mi natomiast znaleźć powody, dla których warto by było używać obiektu tworzonego za pomocą <code>new Boolean</code>.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>typ <code>boolean</code> przyjmuje tylko dwie wartości <code>false</code> i <code>true</code></li><li>wartość w cudzysłowach <code>&#39;true&#39;</code> lub <code>&#39;false&#39;</code> to nie <code>boolean</code> to <code>string</code></li><li>wartość <code>1</code> i <code>0</code> nie reprezentują typu <code>boolean</code> ale są konwertowane na <code>true</code> i <code>false</code></li><li>pamiętajmy co jest konwertowane do wartości fałszywych zgodnie ze specyfikacją ECMAScript</li><li>wszystko co nie jest na liście wartości fałszywych jest wartością prawdziwą</li><li>istnieje obiekt <code>Boolean</code> do opakowania wartości prymitywnej <code>boolean</code>, tworzymy go za pomocą <code>new Boolean</code></li><li>wywołanie funkcyjne <code>Boolean()</code> najlepiej używać jedynie do konwersji</li><li>inicjalizacja zmiennej za pomocą obiektu <code>new Boolean</code> może powodować niespodziewane działanie kodu, unikamy tego</li></ul>',58),s={},t=(0,e(3744).Z)(s,[["render",function(n,a){return o}]])},3744:(n,a)=>{a.Z=(n,a)=>{for(const[e,o]of a)n[e]=o;return n}}}]);