"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[6170],{9029:(a,n,s)=>{s.r(n),s.d(n,{data:()=>e});const e={key:"v-608c64f7",path:"/klasy/rozszerzenie-klas-bazowych/",title:"Rozszerzanie klas bazowych",lang:"pl-PL",frontmatter:{permalink:"/klasy/rozszerzenie-klas-bazowych"},excerpt:"",headers:[{level:2,title:"Dziedziczenie po Array",slug:"dziedziczenie-po-array",children:[]},{level:2,title:"Tworzenie własnych błędów",slug:"tworzenie-własnych-błedow",children:[]},{level:2,title:"Co warto zapamiętać:",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"klasy/04-rozszerzenie-klas-bazowych.md",git:{}}},1397:(a,n,s)=>{s.r(n),s.d(n,{default:()=>t});var e=s(6252);const o=(0,e.uE)('<h1 id="rozszerzanie-klas-bazowych" tabindex="-1"><a class="header-anchor" href="#rozszerzanie-klas-bazowych" aria-hidden="true">#</a> Rozszerzanie klas bazowych</h1><p>Wprowadzenie klas w ES6 i słowa kluczowego <code>extends</code> dało łatwiejsze możliwości rozszerzani klas bazowych, czego do wersji ES5 nie dało się tak łatwo i przyjemnie osiągać. Od teraz możemy rozszerzać takie klasy wbudowane jak <code>Array</code> , <code>Error</code>, <code>Date</code> a nawet <code>Object</code> i zachować pełną funkcjonalność obiektów bazowych, tego właśnie brakowało w ES5.</p><h2 id="dziedziczenie-po-array" tabindex="-1"><a class="header-anchor" href="#dziedziczenie-po-array" aria-hidden="true">#</a> Dziedziczenie po Array</h2><p>Może się zdarzyć, że będziemy w naszej aplikacji potrzebować tablice o specjalnym działaniu. Najlepszym sposobem do osiągnięcia tego w JavaScript jest po prostu rozszerzenie klasy <code>Array</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MyArray</span> <span class="token keyword">extends</span> <span class="token class-name">Array</span> <span class="token punctuation">{</span>\n  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;-&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token function">mapDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Stworzyłem klasę i za pomocą słowa kluczowego <code>extends</code> rozszerzam wbudowaną w JavaScript klasę <code>Array</code>. W mojej nowej klasie dodatkowo nadpisuję metodę <code>toString()</code>, która pochodzi z klasy <code>Array</code>. Dodaje także zupełnie nową metodę, która będzie zwracała tablice z podwojonymi wartościami.</p><p>Zobaczmy jak pracować z taką własną tablicą:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyArray</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [2, 4]</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1-2-3-4</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">mapDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [2, 4, 6, 8]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Jak przy każdej klasie, powołuję obiekt przez wywołanie <code>new MyArray()</code> i do konstruktora podaję wartości oddzielone przecinkiem. Oczywiście nie robimy inicjalizacji w formie literalnej, wywołanie konstruktora jest tutaj potrzebne.</p><p>Na obiekcie pochodzącym z mojej klasy mogę wywołać nie tylko moje metody, ale wszystkie, które pochodzą z <code>Array.prototype</code>. Mam tutaj dostęp do właściwości <code>length</code>, mogę wywołać metodę <code>filter</code>. Mam nadpisaną metodę <code>toString()</code> oraz własną nową metodę <code>mapDouble</code>().</p><p>W ten sposób stworzyłem własną wersję tablic w JavaScript. To właśnie w takich sytuacjach rozszerzanie klas i dziedziczenie właściwości pokazuje swoje ogromne możliwości.</p><p>W mojej klasie nie stworzyłem konstruktora, korzystam z domyślnego wywołania, jeżeli chciałbym umieścić konstruktor wyglądałby on tak:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>items</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n  <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Jeżeli zatem chcemy stworzyć własną funkcjonalność dla tablic, możemy stworzyć swój typ i posługiwać się nim w całej aplikacji. Jest to o wiele lepsze rozwiązanie niż modyfikowanie <code>Array.prototype</code>. Od wersji ES6 w JavaScript proces rozszerzania wbudowanych obiektów JavaScript jest o wiele łatwiejszy.</p><h2 id="tworzenie-własnych-błedow" tabindex="-1"><a class="header-anchor" href="#tworzenie-własnych-błedow" aria-hidden="true">#</a> Tworzenie własnych błędów</h2><p>Rozszerzenie wbudowanej klasy <code>Error</code> może być najczęściej spotykanym przypadkiem wykorzystania dziedziczenia w JavaScript. Co prawda jest wbudowanych kilka klas do obsługi pojawiających się błędów, ale czasem chcemy mieć bardziej szczegółowe informacje, co się stało:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">EmptyArrayError</span> <span class="token keyword">extends</span> <span class="token class-name">Error</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;EmptyArrayError&#39;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Dlatego tworzę własną klasę o nazwie <code>EmptyArrayError</code>, która rozszerza bazową klasę <code>Error</code>. Klasa <code>Error</code> jest bazową klasą dla wszystkich błędów w JavaScript. Dodatkowo tworzę konstruktor, ale nie muszę tego robić. Chcę jednak bardziej dopasować klasę do moich potrzeb.</p><p>Tworząc konstruktor muszę wywołać <code>super()</code> i przekazać tam <code>message</code>, jest to wartość typu string informująca nas jaki błąd powstał. Tworzę także pole <code>name</code>, a tak naprawdę nadpisuję pole <code>name</code> bo istnieje ono także w klasie <code>Error</code>, chce jednak aby to pole reprezentowała nazwę mojego błędu. Standardowo w klasie <code>Error</code>, pole <code>name</code> ustawione jest na nazwę <code>&#39;Error&#39;</code> jako string. Tutaj przypisuję po prostu nazwę mojego błędu.</p><p>Tak przygotowaną klasę mogę teraz wykorzystywać w swoim kodzie</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">EmptyArrayError</span><span class="token punctuation">(</span><span class="token string">&#39;Array should not be empty&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Hipotetyczny przypadek. W jakiejś części kodu tablica nie może być pusta. Instrukcja <code>if</code> sprawdza, czy tablica jest pusta, jeżeli tak to wyrzucam błąd przez użycie <code>throw new EmptyArrayError()</code> i do konstruktora podaję komunikat. Dzięki temu w konsoli pojawia się błąd:</p><div class="language-powershell ext-powershell line-numbers-mode"><pre class="language-powershell"><code>Uncaught EmptyArrayError: Array should not be empty\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Widzimy, że jest to błąd pochodzący z naszej klasy i z naszym komunikatem. Takie klasy z błędami mogą się przydać w wielu miejscach aplikacji, gdy chcemy zareagować na niestandardową sytuację. Każda aplikacja wymaga obsługi błędów, możemy więc tworzyć kolejne klasy błędów jak <code>AccesError</code>, <code>ValidationError</code>, <code>ReadOnlyError</code> i tym podobne.</p><p>Rozszerzane innych klas, szczególnie wielopoziomowe, to kolejne stopnie skomplikowania kodu. Musimy rozważnie używać tych możliwości. W wielu przypadkach jednak może nam to usprawnić działanie aplikacji i poszerzyć możliwości jak w przypadku obsługi błędów. Przy językach obiektowych, jest to jednak coś, co musimy opanować.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać:</h2><ul><li>w ES6 dziedziczenie po wbudowanych klasach w JavaScript jest łatwiejsze niż wcześniej</li><li>można na przykład rozszerzyć klasę <code>Array</code> i stworzyć własną tablicę</li><li>rozszerzenie klas bazowych daje ogromne możliwości na przykład tworzenia własnych błędów aplikacji</li><li>dziedziczenie zawsze wprowadza kolejny stopień skomplikowania, używajmy tam, gdzie musimy, a nie dlatego, że jest fajne</li></ul>',27),p={},t=(0,s(3744).Z)(p,[["render",function(a,n){const s=(0,e.up)("Comments");return(0,e.wg)(),(0,e.iD)(e.HY,null,[o,(0,e.Wm)(s)],64)}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[s,e]of n)a[s]=e;return a}}}]);