"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[7993],{5812:(n,a,s)=>{s.r(a),s.d(a,{data:()=>o});const o={key:"v-3553fd53",path:"/this/this-i-funkcje-strzalkowe/",title:"This i funkcje strzałowe",lang:"pl-PL",frontmatter:{permalink:"/this/this-i-funkcje-strzalkowe"},excerpt:"",headers:[{level:2,title:"Arrow function oraz this",slug:"arrow-function-oraz-this",children:[]},{level:2,title:"Arrow function oraz this w obiektach",slug:"arrow-function-oraz-this-w-obiektach",children:[]},{level:2,title:"Arrow function deklarowane w klasie",slug:"arrow-function-deklarowane-w-klasie",children:[]},{level:2,title:"Co warto zapamiętać:",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"this/03-this-i-funkcje-strzalkowe.md",git:{}}},2045:(n,a,s)=>{s.r(a),s.d(a,{default:()=>t});const o=(0,s(6252).uE)('<h1 id="this-i-funkcje-strzałowe" tabindex="-1"><a class="header-anchor" href="#this-i-funkcje-strzałowe" aria-hidden="true">#</a> This i funkcje strzałowe</h1><p>Arrow function działają nieco inaczej niż zwykłe funkcje, jeśli chodzi o kontekst <code>this</code>. Funkcje te nie mają własnego <code>this</code>. To, że nie mają własnego <code>this</code> nie oznacza, że nie możemy go używać w takiej funkcji. Jeżeli w funkcji strzałowej odwołamy się do <code>this</code> to zostanie ono pożyczone od funkcji nadrzędnej jeżeli istnieje albo zostanie użyte domyślne <code>this</code> z obiektu globalnego.</p><p>Przypominam też, że pracuję bez trybu ścisłego i uruchamiam kod w przeglądarce, więc obiektem globalnym jest <code>window</code> nie używam też modułów ES6 gdzie zachowanie będzie inne.</p><h2 id="arrow-function-oraz-this" tabindex="-1"><a class="header-anchor" href="#arrow-function-oraz-this" aria-hidden="true">#</a> Arrow function oraz this</h2><p>Zobaczmy jak to wszystko działa na przykładach:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">globalArrow</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">globalArrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Window</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Pierwszy przykład to zwykła funkcja strzałkowa zdefiniowana w pliku, jako funkcja globalna. Tutaj działanie funkcji wygląda na takie samo jak w przypadku tradycyjnych funkcji JavaScript. Funkcja wywołana w kontekście globalnym zwraca jako <code>this</code> obiekt <code>window</code>.</p><p>Zdefiniujmy teraz funkcję, która będzie miała włączony tryb ścisły:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">globalArrowStrict</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token string">&#39;use strict&#39;</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token function">globalArrowStrict</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Window</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Pamiętamy, że przy zwykłych funkcjach w trybie ścisłym, funkcja nie posiadała dostępu do obiektu globalnego przez <code>this</code>. Wtedy <code>this</code> wskazuje na <code>undefined</code>. Tryb ścisły nie ma wpływu na arrow function, ponieważ ona sama nie ma w sobie <code>this</code>, jest on zapożyczany z zakresu, który ją otacza, a jest nim zakres globalny.</p><p>Zobaczmy przykłady, kiedy funkcja strzałowa, znajduje się wewnątrz innej funkcji:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">normalStrict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token string">&#39;use strict&#39;</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> <span class="token function-variable function">arrow</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">arrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">normalStrict</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Deklaruję teraz normalną funkcję, która będzie pracowała w trybie ścisłym. W tej funkcji tworze także deklarację funkcji strzałkowej o nazwie <code>arrow()</code> oraz wywołuję tę funkcję. Wypisuję również do konsoli kontekst <code>this</code> prosto z funkcji strzałkowej.</p><p>Wcześniej mówiłem, że <code>use strict</code> nie działa na funkcję strzałkową. Mówiłem też, że funkcje strzałkowe dziedziczą <code>this</code> z kontekstu globalnego, albo z otaczającej jej funkcji. To jest właśnie ten drugi przypadek. Funkcja strzałkowa <code>arrow</code> otrzymuje <code>this</code> po funkcji <code>normalStrict</code>, a ponieważ jest tutaj włączony tryb ścisły, to <code>this</code> jest <code>undefined</code>. Jeżeli usuniemy deklarację <code>use strict</code> to otrzymamy wartość <code>window</code>.</p><p>Mówi się też, że funkcje strzałkowe dziedziczą <code>this</code> z zakresu leksykalnego, a więc z tego miejsca gdzie zostały zadeklarowane. Natomiast tradycyjne funkcje, brały <code>this</code> z kontekstu wywołania, a nie z miejsca deklaracji. Trzeba tylko zwrócić uwagę na istotną rzecz, jeżeli funkcja strzałowa jest zadeklarowana w innej funkcji, dziedziczone jest <code>this</code> z tej funkcji. Jeżeli nie, <code>this</code> będzie ustawione na obiekt globalny lub <code>undefined </code> gdy użyjemy modułów ES6.</p><h2 id="arrow-function-oraz-this-w-obiektach" tabindex="-1"><a class="header-anchor" href="#arrow-function-oraz-this-w-obiektach" aria-hidden="true">#</a> Arrow function oraz this w obiektach</h2><p>Arrow function nie powinny być używane jako metody dla obiektów:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  a<span class="token operator">:</span> <span class="token string">&#39;boo&#39;</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object window</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nobj1<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Rozważmy taki przypadek, gdzie mamy obiekt z polem <code>a</code> z wartością tekstową, oraz pole <code>b</code> do którego dopisujemy arrow function. Mamy więc pod polem <code>b</code> metodę dla tego obiektu, która wypisuje <code>this</code> oraz wartość z pola <code>a</code> za pomocą <code>this.a</code>.</p><p>Wartości jakie zostaną wypisane to <code>window</code> oraz <code>undefined</code>, ponieważ pole <code>a</code> nie istnieje na obiekcie <code>window</code>. Gdyby to była zwykła funkcja, wypisany byłby obiekt, oraz wartość <code>boo</code> z pola <code>a</code>.</p><p>Tak jak wspominałem, arrow function dziedziczy <code>this</code> z innej otaczającej funkcji lub z zakresu globalnego, ponieważ w odróżnieniu do normalnych funkcji, arrow function nie mają swojego kontekstu <code>this</code>. Kontekst ten nie wytworzy się nawet, jeżeli użyjemy jakiegoś obiektu jak w tym przypadku. Funkcja strzałkowa nie ma po prostu własnego <code>this</code> bierze go z miejsca w którym została stworzona.</p><p>Kolejny przykład:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  b<span class="token operator">:</span> <span class="token punctuation">{</span>\n    c<span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token function-variable function">boo</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Window</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\na<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">boo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Stworzyłem obiekt, <code>a</code>, który ma kolejno zagnieżdżone obiekty <code>b</code> oraz <code>c</code>. Dopiero na obiekcie <code>c</code> wywołuję metodę strzałkową <code>boo()</code>, która zwraca obiekt globalny <code>window</code>. Nie ma znaczenia liczba zagnieżdżeń obiektów, obiekty same w sobie nie tworzą zakresu.</p><p>Tutaj znowu jest kontekst domyślny, a w tym przypadku jest to obiekt <code>window</code>. Jeżeli użyjemy trybu ścisłego będzie to dalej obiekt <code>window</code>, natomiast w modułach ES6 będzie to <code>undefined</code>.</p><h2 id="arrow-function-deklarowane-w-klasie" tabindex="-1"><a class="header-anchor" href="#arrow-function-deklarowane-w-klasie" aria-hidden="true">#</a> Arrow function deklarowane w klasie</h2><p>W obiektach tworzonych literalnie, lepiej nie używać metod jako <em>arrow function</em>. Zobaczmy jak to działa w klasach:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Arrow</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Arrow</span>\n  <span class="token punctuation">}</span>\n  <span class="token function-variable function">boo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Arrow</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Przygotowałem klasę <code>Arrow</code>, która w konstruktorze tworzy pole <code>foo</code> do którego dopisuję arrow function. Również wykorzystuję na dzisiejszy dzień zupełną nowość i możliwość stworzenia nie pola z przypisaną funkcją strzałową, ale metodę strzałkową o nazwie <code>boo()</code>. W roku 2020 jest to wciąż nowa propozycja dla JavaScript, która oficjalnie nie jest jeszcze zaimplementowana, ale niektóre przeglądarki mogą ją już wspierać.</p><p>Gdy stworzymy obiekt z takiej klasy:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> arrow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Arrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\narrow<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\narrow<span class="token punctuation">.</span><span class="token function">boo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>i wywołamy obie funkcje strzałkowe, zobaczymy, że mają prawidłowe odniesienie do <code>this</code>. Wskazują na obiekt, który powstał.</p><div class="language-powershell ext-powershell line-numbers-mode"><pre class="language-powershell"><code>Arrow <span class="token punctuation">{</span>boo: ƒ<span class="token punctuation">,</span> foo: ƒ<span class="token punctuation">}</span>\n\tboo: <span class="token punctuation">(</span><span class="token punctuation">)</span> =&gt; console<span class="token punctuation">.</span>log<span class="token punctuation">(</span>this<span class="token punctuation">)</span>\n\tfoo: <span class="token punctuation">(</span><span class="token punctuation">)</span> =&gt; console<span class="token punctuation">.</span>log<span class="token punctuation">(</span>this<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Tworzenie obiektów za pomocą <code>new</code> powoduje wywołanie konstruktora i stworzenie obiektu, który automatycznie pełni kontekst dla <code>this</code>. Dlatego <em>arrow functions</em> jako metody w klasach są bezpieczne. Pamiętajmy, że klasy to też funkcje, więc funkcje strzałkowe jako metody mają ten <code>this</code>, którego oczekujemy.</p><p>Widzimy, że dla kontekstu <code>this</code> powstaje coraz więcej zasad, a to jeszcze nie koniec.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać:</h2><ul><li>funkcje strzałkowe nie mają własnego <code>this</code> muszą go dziedziczyć</li><li>funkcje strzałkowe dziedziczą <code>this</code> z otaczającego je zakresu</li><li>gdy funkcja strzałowa istnieje w innej funkcji, otrzymuje <code>this</code> od tej funkcji</li><li>w pozostałych przypadkach <code>this</code> jest obiektem globalnym lub <code>undefined</code></li><li>funkcje strzałkowe nie sprawdzają się jako metody w obiektach, ponieważ nie mają własnego <code>this</code> i nie mogą być wywołane z kontekstem obiektu w którym istnieją</li><li>funkcje strzałkowe są bezpieczne w obiektach stworzonych z klas</li><li>przykłady pokazane są bez trybu ścisłego oraz bez modułów ES6</li></ul>',37),e={},t=(0,s(3744).Z)(e,[["render",function(n,a){return o}]])},3744:(n,a)=>{a.Z=(n,a)=>{for(const[s,o]of a)n[s]=o;return n}}}]);