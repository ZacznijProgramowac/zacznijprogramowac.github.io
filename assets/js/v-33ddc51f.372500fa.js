"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[5880],{7237:(a,n,o)=>{o.r(n),o.d(n,{data:()=>e});const e={key:"v-33ddc51f",path:"/prototypy/nie-uzywamy-__proto__/",title:"Nie używamy proto",lang:"pl-PL",frontmatter:{permalink:"/prototypy/nie-uzywamy-__proto__"},excerpt:"",headers:[{level:2,title:"Nie używamy proto",slug:"nie-uzywamy-proto-1",children:[]},{level:2,title:"Metoda Object.getPrototypeOf",slug:"metoda-object-getprototypeof",children:[]},{level:2,title:"Metoda Object.setPrototypeOf",slug:"metoda-object-setprototypeof",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"prototypy/04-nie-uzywamy-__proto__.md",git:{}}},5912:(a,n,o)=>{o.r(n),o.d(n,{default:()=>t});const e=(0,o(6252).uE)('<h1 id="nie-uzywamy-proto" tabindex="-1"><a class="header-anchor" href="#nie-uzywamy-proto" aria-hidden="true">#</a> Nie używamy <strong>proto</strong></h1><p>W ostatnich przykładach często wspominałem o wewnętrznej właściwości <code>[[Prototype]]</code> oraz o getterze i setterze o nazwie <code>__proto__</code>. W tym dziale czas na sprostowanie kilku rzeczy, powiemy sobie dlaczego nie należy używać akcesora <code>__proto__</code> i co ewentualnie używać w zamian.</p><h2 id="nie-uzywamy-proto-1" tabindex="-1"><a class="header-anchor" href="#nie-uzywamy-proto-1" aria-hidden="true">#</a> Nie używamy <strong>proto</strong></h2><p>Do właściwości obiektu <code>[[Prototype]]</code> możemy się dostać przez akcesor <code>__proto__</code>. Oznacza to, że możemy zarówno pobierać prototyp, ale też ustawiać go ręcznie. Jest bowiem możliwość przypisania po prostu własnego prototypu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token punctuation">{</span>\n  surname<span class="token operator">:</span> <span class="token string">&#39;Rambo&#39;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nb<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> a<span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>name<span class="token punctuation">,</span> b<span class="token punctuation">.</span>surname<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John Rambo</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>W tym przypadku tworzę obiekt <code>a</code> oraz obiekt <code>b</code>. W obiekcie <code>b</code> wykorzystuję właściwość <code>__proto__</code> i przypisuję jej obiekt <code>a</code>. W ten sposób ustawiam prototyp dla obiektu <code>b</code>. Mogę teraz na obiekcie <code>b</code> wywołać właściwość <code>name</code>, która została odziedziczona po obiekcie <code>a</code>.</p><p>Działa to niemalże tak samo jak z <code>Object.create</code>. Ustawiliśmy ręcznie prototyp dla obiektu przez właściwość <code>__proto__</code>.</p><p>Pomimo tego, że mamy możliwość używania właściwości <code>__proto__</code> nie należy tego robić. Właściwość ta kiedyś nie istniała nawet w specyfikacji, ale i tak była zaimplementowana w przeglądarkach. Ponieważ było to trochę kontrowersyjne, to ostatecznie ujednolicono dokumentację i <code>__proto__</code> pojawiło się w ESCMAScript 2015. Jednak metoda ta nie jest zalecana do używania w kodzie. Do pobierania prototypu i jego ustawiania mamy inne metody, które sobie omówimy.</p><h2 id="metoda-object-getprototypeof" tabindex="-1"><a class="header-anchor" href="#metoda-object-getprototypeof" aria-hidden="true">#</a> Metoda Object.getPrototypeOf</h2><p>Pierwszą metodą do operacji na prototypie jest <code>Object.getPrototypeOf</code>. Jest to metoda, która zwraca prototyp danego obiektu, czyli właściwość <code>[[Prototype]]</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>proto <span class="token operator">===</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>W tym kodzie jako obiekt stworzyłem tablice. Za pomocą metody <code>Object.getPrototypeOf</code> pobieram obiekt prototypu i przypisuję go do zmiennej <code>proto</code>. Obiekt ten porównuję z <code>Array.prototype</code> i otrzymuję wartość <code>true</code>. Jak widzimy jest to porównanie referencji, oznacza to, że we właściwości <code>[[Prototype]]</code> naszego obiektu znajduje się referencja do głównego prototypu <code>Array.prototype</code>.</p><p>Dlatego też każda zmiana w <code>Array.prototype</code> dotyczy potem każdej tablicy w naszej aplikacji. Zobaczmy co się stanie jeżeli zmodyfikuję pobrany prototyp, który znajduje się w zmiennej <code>proto</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>proto<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">&#39;boo&#39;</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// boo</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Do pobranego prototypu dopisałem właściwość <code>foo</code> i próbuję ją wypisać przez <code>Array.prototype.foo</code>. Widzimy, że ta właściwość jest już tutaj również dostępna. Musimy zatem być świadomi, że nawet modyfikując prototyp w naszym obiekcie, dokonujemy zmiany globalnej, ponieważ operujemy na referencji do obiektów.</p><h2 id="metoda-object-setprototypeof" tabindex="-1"><a class="header-anchor" href="#metoda-object-setprototypeof" aria-hidden="true">#</a> Metoda Object.setPrototypeOf</h2><p>Kolejną metodą jest <code>Object.setPrototypeOf</code>. Jest to metoda, która służy do ustawiania prototypu. Jest ona jednak bardzo wolna i może poważnie zaszkodzić wydajności w naszej aplikacji:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nObject<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>obj2<span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;John&#39;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Mamy tutaj dwa obiekty. Pierwszy z nich posiada właściwość <code>name</code>. Drugi natomiast jest pustym obiektem. Wykorzystuję metodę <code>Object.setPrototypeOf</code> i przekazuję dwa parametry. Pierwszy parametr to obiekt, któremu chcę ustawić prototyp, drugi parametr to prototyp dla tego obiektu. Ostatecznie wiec drugi obiekt będzie dziedziczył z obiektu pierwszego. Po tej operacji widzimy, że mam dostęp do pola <code>name</code> w obiekcie <code>obj2</code>.</p><p>Jeżeli już musimy zmienić prototyp obiektu, możemy tego dokonać w taki właśnie sposób.</p><p>Poznaliśmy dwie metody do operowania na prototypie. Nie oznacza to jednak, że powinniśmy operować tymi metodami w naszym codziennym kodzie. Zmiana prototypu jest bardzo powolną operacją. W dodatku jest to operacja globalna, która wpłynie na każde miejsce, gdzie wywoływany jest obiekt. Zazwyczaj nie będziecie ręcznie modyfikować prototypów. Jeżeli jednak natraficie na taki kod, będziecie mieli większą świadomość tego co dzieje się w aplikacji.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>właściwość <code>__proto__</code> nie powinna być przez nas używana, może nam posłużyć tylko do edukacji</li><li>do pobierania prototypu z obiektu mamy metodę <code>Object.getPrototypeOf</code></li><li>do ustawiania prototypu w obiekcie mamy metodę <code>Object.setPrototypeOf</code></li><li>operacje na prototypie obiektu są bardzo wolne i psują optymalizację aplikacji</li></ul>',23),s={},t=(0,o(3744).Z)(s,[["render",function(a,n){return e}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[o,e]of n)a[o]=e;return a}}}]);