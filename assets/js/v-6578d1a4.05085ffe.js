"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[6828],{3217:(a,n,s)=>{s.r(n),s.d(n,{data:()=>e});const e={key:"v-6578d1a4",path:"/this/this-w-obiektach/",title:"This w obiektach",lang:"pl-PL",frontmatter:{permalink:"/this/this-w-obiektach"},excerpt:"",headers:[{level:2,title:"This jako pole w obiekcie",slug:"this-jako-pole-w-obiekcie",children:[]},{level:2,title:"This przy wywołaniu konstruktora",slug:"this-przy-wywołaniu-konstruktora",children:[]},{level:2,title:"This w klasie",slug:"this-w-klasie",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"this/02-this-w-obiektach.md",git:{}}},3340:(a,n,s)=>{s.r(n),s.d(n,{default:()=>p});var e=s(6252);const o=(0,e.uE)('<h1 id="this-w-obiektach" tabindex="-1"><a class="header-anchor" href="#this-w-obiektach" aria-hidden="true">#</a> This w obiektach</h1><p>W tej części przyjrzymy się dokładnie jak <code>this</code> wygląda w obiektach JavaScript. Przyjrzymy się kilku przypadkom, które mogą nas zadziwić. Rozpatrzenie kilku przypadków pomoże nam zrozumieć wskaźnik <code>this</code>.</p><p>Na początek ważna uwaga, pracuję bez trybu ścisłego, czyli nie używam <code>use strict</code>, a także nie uruchamiam skryptu za pomocą żadnego bundlera, jak <em>Parcel</em> czy <em>Webpack</em> i nie używam modułów ES6. Wczytuję plik JavaScript za pomocą pliku HTML i uruchamiam w przeglądarce. Moim obiektem globalnym będzie zatem obiekt <code>window</code>. W innych konfiguracjach ten kod może działać inaczej.</p><h2 id="this-jako-pole-w-obiekcie" tabindex="-1"><a class="header-anchor" href="#this-jako-pole-w-obiekcie" aria-hidden="true">#</a> This jako pole w obiekcie</h2><p>Pierwszy przykład to zwykły obiekt, które zadeklarujemy w formie literalnej:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  a<span class="token operator">:</span> <span class="token string">&#39;some object&#39;</span><span class="token punctuation">,</span>\n  b<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">c</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Mamy tutaj obiekt, który posiada trzy właściwości. Do pola <code>b</code> mam dopisaną mam wartość <code>this</code>. Natomiast do pola <code>c</code> mam dopisaną metodę, która zwraca <code>this</code>. Sprawdzimy teraz za pomocą <code>conole.log</code> czym jest <code>this</code> w tych dwóch różnych sytuacjach:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {a: &quot;some object&quot;, b: Window, c: ƒ}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>To co zostało dopisane do pola <code>b</code> jest obiektem <code>window</code>. Okazuje się, więc, że <code>this</code> wskazuje na obiekt globalny. Pole <code>b</code> znajduje się w obiekcie <code>obj1</code> i wywołanie nastąpiło przez <code>obj1.b</code>. Wcześniej mówiłem, że <code>this</code> jest tym co stoi przed kropką i jest to prawda, ale dotyczy to tylko wywołania metody. Kontekst <code>this</code> dotyczy tylko wywołania funkcji i metod, wtedy ustalana jest wartość dla <code>this</code>.</p><p>W tym przypadku pole <code>b</code> po prostu przetrzymuje wartość <code>this</code>, która jest wartością domyślną, czyli obiektem globalnym. Inny kontekst <code>this</code> tworzy się w momencie wywołania funkcji czy metody, a tutaj mamy zwykłe przypisanie <code>this</code> do pola <code>b</code> i odczytanie tej wartości przez <code>console.log</code>.</p><p>Wywołanie metody <code>c</code> daje już inny wynik. W tym przypadku <code>this</code> wskazuje na obiekt. Ponieważ jest to metoda i wywołanie następuje przez zadeklarowany obiekt, kontekstem dla <code>this</code> w tej metodzie staje się ten obiekt przed kropką. Następuje normalne wywołanie metody w jakimś kontekście, nie jak w przypadku pola <code>b</code> tylko przypisanie i odczytanie wartości.</p><h2 id="this-przy-wywołaniu-konstruktora" tabindex="-1"><a class="header-anchor" href="#this-przy-wywołaniu-konstruktora" aria-hidden="true">#</a> This przy wywołaniu konstruktora</h2><p>Przyjrzyjmy się przypadkowi tworzenia obiektów z wywołaniem konstruktora za pomocą funkcji, oraz za pomocą definicji klasy:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Pierwszy przypadek to zwykła funkcja, która odwołuje się w sobie do <code>this.a</code> i przypisuje wartość <code>foo</code>. Jeżeli funkcję wywołamy z konstruktorem czyli za pomocą <code>new Person()</code> stworzymy obiekt:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Jeżeli wywołujemy <code>new</code> tworzony jest obiekt i automatycznie obiekt ten staje się kontekstem dla <code>this</code> w tej funkcji. Nie ma tutaj znaczenia gdzie wywołujemy <code>new Person()</code>. Użycie <code>new</code> sprawia, że obiekt, który powstaje z konstruktora tej funkcji staje się automatycznie kontekstem dla <code>this</code>. W przypadku wywoływania funkcji przez <code>new</code> nie musimy się martwić czym będzie kontekst.</p><p>Sprawdźmy jeszcze, co się stanie, jeżeli wywołamy funkcję bez <code>new</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Funkcja została wywołana z kontekstem domyślnym, czyli na obiekcie <code>window</code>. W takim przypadku <code>this</code> w tej funkcji wskazuje na obiekt globalny <code>window</code>, albo w trybie ścisłym na <code>undefined</code> i wtedy zobaczycie błąd.</p><p>Takie wywołanie ostatecznie sprawiło, że przez <code>this</code>, pole <code>a</code> zostało dopisane do obiektu <code>window</code>. Ponieważ ta funkcja służy do tworzenia obiektów, nie powinniśmy raczej takich funkcji wywoływać bez użycia słowa kluczowego <code>new</code>.</p><h2 id="this-w-klasie" tabindex="-1"><a class="header-anchor" href="#this-w-klasie" aria-hidden="true">#</a> This w klasie</h2><p>Przed nami kolejny przypadek dotyczący klas, nie ma tutaj dużej różnicy między funkcją wywołaną z konstruktorem, a klasą.</p><p>Warto jednak przyjrzeć się tak zbudowanej klasie:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>\n  a <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Wykorzystałem tutaj nowy zapis tworzenia pola w klasie. Pole <code>a</code> zostaje po prostu zdefiniowane bez użycia metody <code>constructor</code>. Przypadek ten jest podobny do obiektu, który omawialiśmy na początku tego rozdziału. Tak zdefiniowane pole jest nowością w JavaScript i może nie działać w każdej przeglądarce czy w node.js. W roku 2020 jeszcze oficjalnie nie stanowi część języka JavaScript i możecie potrzebować skryptów polyfills.</p><p>Dodatkowo mamy też konstruktor, który definiuje pole <code>b</code> w standardowy sposób. Do obu pól dopisuję <code>this</code>. Tworzę obiekt i od razu wypisuję do konsoli:</p><div class="language-powershell ext-powershell line-numbers-mode"><pre class="language-powershell"><code>MyClass <span class="token punctuation">{</span>a: MyClass<span class="token punctuation">,</span> b: MyClass<span class="token punctuation">,</span> c: <span class="token string">&quot;foo&quot;</span><span class="token punctuation">}</span>\n\ta: MyClass <span class="token punctuation">{</span>a: MyClass<span class="token punctuation">,</span> b: MyClass<span class="token punctuation">,</span> c: <span class="token string">&quot;foo&quot;</span><span class="token punctuation">}</span>\n\tb: MyClass <span class="token punctuation">{</span>a: MyClass<span class="token punctuation">,</span> b: MyClass<span class="token punctuation">,</span> c: <span class="token string">&quot;foo&quot;</span><span class="token punctuation">}</span>\n\tc: <span class="token string">&quot;foo&quot;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Widzimy, że zarówno pole <code>a</code> jak i <code>b</code> wskazuje na nowo stworzony obiekt. Działa to tak samo jak z funkcją i wywołaniem jej przez użycie <code>new</code>. Również to samo działanie jest przy klasach. Jeżeli tworzymy obiekt z klasy, zawsze musimy wywołać <code>new</code> i w ten sposób tworzony obiekt automatycznie staje się kontekstem <code>this</code>.</p><p>Może nam się wydawać, że pole <code>a</code> nie jest w żadnej metodzie i że jest to podobny przypadek do obiektu z polem <code>b</code> gdzie przypisaliśmy do niego <code>this</code>, przypadek ten rozważaliśmy na początku:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  a<span class="token operator">:</span> <span class="token string">&#39;some object&#39;</span><span class="token punctuation">,</span>\n  b<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">c</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Przy klasach działa to jednak inaczej, ponieważ przy użyciu słowa kluczowego <code>new</code> następuje automatyczne dowiązanie do obiektu, który zostanie wytworzony przez konstruktor klasy. Dlatego w klasach, <code>this</code> ma zawsze kontekst wytworzonego z tej klasy obiektu. W głębi kodu JavaScript, klasy to funkcje, więc tak naprawdę przez słowo kluczowe <code>new</code> wywołujemy funkcje.</p><p>Używając czy to funkcji czy to klas ze słowem kluczowym <code>new</code> nie musimy się specjalnie martwić o kontekst <code>this</code> ponieważ będzie on zawsze obiektem, który powstaje z takiego wywołania. Nie ma tutaj znaczenia w jakim miejscu kodu występuje wywołanie.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>wiązanie <code>this</code> następuje tylko przy wywołaniu funkcji czy metody</li><li>domyślnie <code>this</code> wskazuje na obiekt globalny, w przeglądarce jest to <code>window</code></li><li>gdy tworzymy obiekt za pomocą słowa kluczowego <code>new</code> , <code>this</code> będzie nowo stworzonym obiektem</li><li>gdy w stworzonym obiekcie literalnym stworzymy zwykłe pole i dopiszemy <code>this</code>, jest to kontekst domyślny czyli obiekt globalny</li></ul>',35),t={},p=(0,s(3744).Z)(t,[["render",function(a,n){const s=(0,e.up)("Comments");return(0,e.wg)(),(0,e.iD)(e.HY,null,[o,(0,e.Wm)(s)],64)}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[s,e]of n)a[s]=e;return a}}}]);