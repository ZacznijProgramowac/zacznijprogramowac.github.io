"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[3801],{4914:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-63849030",path:"/zakresy-domkniecia-moduly/zakres-funkcyjny/",title:"Zakres funkcji",lang:"pl-PL",frontmatter:{permalink:"/zakresy-domkniecia-moduly/zakres-funkcyjny"},excerpt:"",headers:[{level:2,title:"Funkcje w funkcji",slug:"funkcje-w-funkcji",children:[]},{level:2,title:"Funkcje IIFE",slug:"funkcje-iife",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"zakresy-domkniecia-moduly/03-zakres-funkcyjny.md",git:{}}},7688:(n,a,s)=>{s.r(a),s.d(a,{default:()=>t});var e=s(6252);const o=(0,e.uE)('<h1 id="zakres-funkcji" tabindex="-1"><a class="header-anchor" href="#zakres-funkcji" aria-hidden="true">#</a> Zakres funkcji</h1><p>Kolejny zakres, jaki istnieje w JavaScript to zakres funkcyjny. Zakres funkcyjny definiowany jest przez funkcję. Wszystko, co zadeklarowane jest w ciele funkcji, nie jest dostępne na zewnątrz.</p><p>Zerknijmy na przykład funkcji z zadeklarowanymi trzema zmiennymi:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> bird <span class="token operator">=</span> <span class="token string">&#39;a bird&#39;</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token string">&#39;a cat&#39;</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> myDog <span class="token operator">=</span> <span class="token string">&#39;my dog&#39;</span><span class="token punctuation">;</span>\n  <span class="token comment">//...</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// console.log(bird, car, myDog); // error</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>W JavaScript każda funkcja tworzy swój zakres. Nie możemy dostać się do zmiennych zadeklarowanych w funkcji z zewnątrz. Kod w funkcji dostępny jest tylko wewnątrz funkcji. Dotyczy to nawet zmiennych deklarowanych za pomocą <code>var</code>.</p><p>Funkcje w JavaScript są więc doskonałym miejscem do deklaracji kodu, który nie będzie kolidował z innymi nazwami, a przede wszystkim z zakresem globalnym.</p><p>Pamiętajmy jednak przypadek zmiennej niezadeklarowanej:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">notDeclared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  foo <span class="token operator">=</span> <span class="token string">&#39;boo&#39;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">notDeclared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;boo&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Ta zmienna <code>foo</code> od razu stanie się zmienną globalną. Ponieważ nie posiada żadnej deklaracji, jak <code>let, const i var</code>. Kompilator, gdy na nią natrafi, po prostu utworzy ją w obiekcie globalnym, w przeglądarce będzie to <code>window</code>. Oczywiście w nowoczesnym JavaScript nie musimy się martwić o takie zmienne, jednak w starym kodzie JavaScript możecie takie zmienne spotkać.</p><h2 id="funkcje-w-funkcji" tabindex="-1"><a class="header-anchor" href="#funkcje-w-funkcji" aria-hidden="true">#</a> Funkcje w funkcji</h2><p>W funkcjach możemy deklarować nie tylko zmienne, ale też inne funkcje:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> boo <span class="token operator">=</span> <span class="token string">&#39;boo&#39;</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> foo<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;foo&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>W tym przypadku mamy funkcje <code>outer</code>, która posiada w sobie zadeklarowaną zmienną <code>foo</code> oraz wewnętrzną funkcję anonimową, która jest zwracana od razu z funkcji zewnętrznej.</p><p>Funkcja zewnętrzna <code>outer</code> nie ma dostępu do zakresu funkcji wewnętrznej i nie może wywołać zmiennej <code>boo</code>. Czyli do zakresu funkcji nie możemy się dostać z zewnątrz.</p><p>Funkcja wewnętrzna posiada za to dostęp do danych zadeklarowanych w funkcji wyżej, a nawet do zakresu globalnego. Nie ważne jak wiele funkcji będzie zagnieżdżonych. Każda funkcja ma dostęp do wszystkich zakresów, które ją otaczają, aż do zakresu globalnego.</p><p>Można powiedzieć, że zakres funkcyjny to taka prywatna przestrzeń dla kodu i często funkcja jest używana do ukrywania kodu. W przypadku tej funkcji <code>outer</code>, nie mamy bezpośredniego dostępu do zmiennej <code>foo</code>, dopiero wywołanie innej funkcji wewnętrznej zwraca nam wartość. W ten sposób utworzyliśmy sobie coś na kształt zmiennej prywatnej.</p><h2 id="funkcje-iife" tabindex="-1"><a class="header-anchor" href="#funkcje-iife" aria-hidden="true">#</a> Funkcje IIFE</h2><p>Ponieważ funkcja okazuje się fajnym sposobem na stworzenie zakresu i także ukrycie kodu w tym zakresie, powstał ciekawy wzorzec nazwany Immediately-Invoked Function Expression (IIFE):</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// Immediately-Invoked Function Expression (IIFE):</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Zanim pojawiły się moduły, w specyfikacji ES6 był to często wykorzystywany wzorzec do unikania ingerencji w obiekt globalny i tworzenia zamkniętego zakresu dla własnego kodu, zaczęto używać IIFE:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;iife&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Jej konstrukcja jest trochę dziwna, ale cała funkcja umieszczona jest w nawiasach okrągłych, a na końcu jeszcze raz użyte są nawiasy okrągłe do wykonania funkcji. Taki zapis od razu wykonuje funkcję i wykonuje cały kod w jej środku. Funkcja ta ma nadal dostęp do zakresu globalnego, ale nie istnieje w obiekcie globalnym <code>window</code>.</p><p>Jest sporo różnych zapisów tych funkcji, pokażę Wam jeszcze dwa:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> iife2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">zzz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token string">&#39;IIFE&#39;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Z tej funkcji możemy coś zwrócić i przechwycić do zmiennej. W tym przypadku zwracamy wartość string.</p><p>Możemy też:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">global</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>global<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>do funkcji przekazywać parametry, w tym przypadku przekazuję obiekt <code>window</code>. Oczywiście funkcja ma dostęp do obiektu <code>window</code>. Jednak przekazanie go w ten sposób pozwala na operowanie tym obiektem wewnętrznie bez poszukiwania go za każdym razem w zakresie nadrzędnym. Druga ważna rzecz to możemy przekazać tam każdy inny obiekt globalny bez względu na środowisko pracy.</p><p>Chociaż funkcje IIFE są dzisiaj mniej popularne, to nadal możecie je spotkać w kodzie, na przykład, gdy traficie na framework jQuery. Dawniej były bardzo popularne do tworzenia kodu w oddzielnym zakresie i unikania zakresu globalnego.</p><p>Na podstawie tej funkcji powstał także wzorzec modułu, który był używany, zanim pojawiły się moduły ES6. O modułach będzie zupełnie nowy dział i tam wrócimy do tego tematu.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>funkcja tworzy zakres funkcyjny, do tego zakresu nie można się dostać z zewnątrz</li><li>inne zagnieżdżone bloki czy funkcje mają zawsze dostęp do zakresu ich otaczającego</li><li>funkcja pozwala na ukrywanie kodu w swoim zakresie i na kontrolowaniu dostępu</li><li>nieważne ile zagnieżdżeń funkcji, dostęp mamy do wszystkich otaczających zakresów</li></ul>',32),p={},t=(0,s(3744).Z)(p,[["render",function(n,a){const s=(0,e.up)("Comments");return(0,e.wg)(),(0,e.iD)(e.HY,null,[o,(0,e.Wm)(s)],64)}]])},3744:(n,a)=>{a.Z=(n,a)=>{for(const[s,e]of a)n[s]=e;return n}}}]);