"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[5736],{2800:(a,n,s)=>{s.r(n),s.d(n,{data:()=>e});const e={key:"v-12f5e86f",path:"/petle/petla-for/",title:"Pętla for",lang:"pl-PL",frontmatter:{permalink:"/petle/petla-for"},excerpt:"",headers:[{level:2,title:"Wyjście z pętli za pomocą break",slug:"wyjscie-z-petli-za-pomoca-break",children:[]},{level:2,title:"Wyjście z iteracji za pomocą continue",slug:"wyjscie-z-iteracji-za-pomoca-continue",children:[]},{level:2,title:"Problemy z pętlą for",slug:"problemy-z-petla-for",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"petle/01-petla-for.md",git:{}}},5601:(a,n,s)=>{s.r(n),s.d(n,{default:()=>o});const e=(0,s(6252).uE)('<h1 id="petla-for" tabindex="-1"><a class="header-anchor" href="#petla-for" aria-hidden="true">#</a> Pętla for</h1><p>Najbardziej znaną pętlą w programowaniu jest pętla <code>for</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 1 2 3 4</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Pętla ta jest znana z wielu innych języków jak Java, C, C ++. W nawiasach okrągłych mamy inicjalizacyjną zmienną <code>i</code>, potem mamy warunek dla całej pętli i inkrementowanie zmiennej <code>i</code>.</p><p>Warunkiem w pętli może być dosłownie wszystko:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token boolean">true</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 1 2 3 4</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Możemy tutaj wstawić nawet wartość <code>true</code>, oczywiście taka pętla będzie wykonywała się w nieskończoność, ponieważ warunek będzie zawsze prawdziwy.</p><p>Możemy też stworzyć <code>for</code> pomijając nie które jej kroki lub nawet wszystkie:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0, 1, 2, 3, 4</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;i:&#39;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token comment">// 4</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>W tym przypadku deklarujemy wartość inicjalizacyjną poza pętlą i pomijajmy ten krok w pętli <code>for</code> zostawiając puste miejsce. Zostawiamy jednak średnik. Zauważ też, że zmienna <code>i</code> jest teraz dostępna poza pętlą for. I możliwe jest odczytanie wartości poza blokiem pętli.</p><p>Możemy takie kombinacje robić z każdym elementem pętli for. Wydaje mi się jednak, że takie formy nie są czytelne i raczej powinniśmy ich unikać.</p><p>Możemy nawet stworzyć pustą pętlę:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// infinite</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Taka pętla jest oczywiście nieskończona, w niektórych przypadkach może się przydać. Należy tylko pamiętać, że pusta pętla dla poprawności składni musi zawierać średniki.</p><h2 id="wyjscie-z-petli-za-pomoca-break" tabindex="-1"><a class="header-anchor" href="#wyjscie-z-petli-za-pomoca-break" aria-hidden="true">#</a> Wyjście z pętli za pomocą <code>break</code></h2><p>Gdy nasza pętla jest nieskończona lub gdy spełnił się jakiś warunek i nie musi się dłużej iterować, możemy wyjść z pętli za pomocą <code>break</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Break:&#39;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 50</span>\n        <span class="token keyword">break</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Gdy pętla dojdzie do momentu, gdzie <code>i</code> będzie miało wartość 50, pętla zostanie przerwana. Instrukcja <code>break</code> może się przydać w wielu przypadkach gdy chcemy natychmiast zakończyć pętlę lub gdy oczekujemy na konkretny warunek. Warto wspomnieć, że popularna metoda <code>forEach</code>, która często zastępuje nam instrukcję <code>for</code> nie posiada instrukcji <code>break</code> . <code>forEach</code> omówimy sobie jednak przy omawianiu metod obiektów <code>array</code>.</p><h2 id="wyjscie-z-iteracji-za-pomoca-continue" tabindex="-1"><a class="header-anchor" href="#wyjscie-z-iteracji-za-pomoca-continue" aria-hidden="true">#</a> Wyjście z iteracji za pomocą <code>continue</code></h2><p>Inną delikatniejszą formą <code>break</code> jest instrukcja <code>continue</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;odd:&#39;</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1, 3</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>W tej pętli używam <code>continue</code> do tego aby pominąć liczby parzyste. Jeżeli mój warunek <code>if</code> znajdzie liczbę parzystą wywołuje instrukcję <code>continue</code> co oznacza przerwanie wykonywania kodu w ciele pętli <code>for</code> i przejście do następnej iteracji. Instrukcja <code>continue</code> nie przerywa wykonywania pętli, ale przerywa obecną iterację.</p><h2 id="problemy-z-petla-for" tabindex="-1"><a class="header-anchor" href="#problemy-z-petla-for" aria-hidden="true">#</a> Problemy z pętlą for</h2><p>Pętla for, deklaracja <code>var</code> oraz asynchroniczność to pewien znany problem z którym możecie się spotkać:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 3, 3, 3</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;k: &#39;</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token comment">// 3</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>W tym przypadku deklaracja wartości początkowej nastąpiła za pomocą <code>var</code>. Zmienna <code>k</code> jest zatem dostępna nie tylko w pętli <code>for</code>, ale też poza nią. Ponadto gdy wywołamy kod asynchroniczny to zobaczymy, że produkuje on tylko wartość <code>3</code>. Nie przestrzega więc warunku, że pętla powinna wyświetlać tylko wartości mniejsze od 3.</p><p>Jeden problem to taki, że jest to asynchroniczność i kod ten wykonuje się gdy zakończy się pętla. Gdy zakończy się pętla, zmienna k, ma wartość 3. Drugi problem to taki, że zmienna<code>var</code> nie respektuje zakresu blokowego, jest tutaj zmienną globalną.</p><p>Rozwiązaniem jest zawsze użycie <code>let</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 0, 1, 2</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>W tym przypadku mamy prawidłowe wyniki. <code>Let</code> przestrzega zakres blokowy. Przy każdej iteracji powstaje domknięcie i w ten sposób kolejne iteracje zmiennej <code>k</code> dostępne są dla wywołania asynchronicznego.</p><p>Pytanie o taką pętlę możecie spotkać na rozmowie o pracę. O asynchroniczności, zakresach i domknięciach będziemy natomiast rozmawiać w kolejnych działach. Natomiast teraz należy pamiętać, że do inicjalizacji w pętli używamy zawsze <code>let</code>.</p><p>Nie używamy natomiast inicjalizacji za pomocą <code>const</code>. Ponieważ inicjalizator w trakcie iteracji przybiera nowe wartości, jak wiemy zmienne zainicjalizowane za pomocą <code>const</code> nie mogą zmieniać wartości.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>pętla <code>for</code> znana jest z wielu różnych języków programowania</li><li>pętla <code>for</code> jest bardzo elastyczne i nie są wymagane jej wszystkie elementy</li><li>instrukcja <code>break</code> przerywa pętlę</li><li>instrukcja <code>conitnue</code> przerywa daną iterację pętli</li></ul>',34),p={},o=(0,s(3744).Z)(p,[["render",function(a,n){return e}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[s,e]of n)a[s]=e;return a}}}]);