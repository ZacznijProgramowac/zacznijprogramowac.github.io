"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[3049],{8986:(n,a,s)=>{s.r(a),s.d(a,{data:()=>o});const o={key:"v-66781411",path:"/prototypy/prototyp-funkcji/",title:"Prototyp funkcji",lang:"pl-PL",frontmatter:{permalink:"/prototypy/prototyp-funkcji"},excerpt:"",headers:[{level:2,title:"Obiekt funkcyjny",slug:"obiekt-funkcyjny",children:[]},{level:2,title:"Wywołanie konstruktora funkcji",slug:"wywołanie-konstruktora-funkcji",children:[]},{level:2,title:"Słówko new jest bardzo ważne",slug:"słowko-new-jest-bardzo-wazne",children:[]},{level:2,title:"Sprawdzanie typu przez instanceof",slug:"sprawdzanie-typu-przez-instanceof",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"prototypy/05-prototyp-funkcji.md",git:{}}},5099:(n,a,s)=>{s.r(a),s.d(a,{default:()=>p});var o=s(6252);const e=(0,o.uE)('<h1 id="prototyp-funkcji" tabindex="-1"><a class="header-anchor" href="#prototyp-funkcji" aria-hidden="true">#</a> Prototyp funkcji</h1><p>Funkcje w JavaScript tak naprawdę są obiektami, a obiekty te mają swój specjalny podtyp <code>Function</code>. Gdy więc tworzymy funkcję, to tak naprawdę tworzymy obiekt, do którego możemy zaglądnąć. Jest tam jedna bardzo interesująca rzecz.</p><h2 id="obiekt-funkcyjny" tabindex="-1"><a class="header-anchor" href="#obiekt-funkcyjny" aria-hidden="true">#</a> Obiekt funkcyjny</h2><p>Na początek stworzę prostą funkcję:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;John rambo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>W ogóle na razie nie interesuje nas, co robi ta funkcja, bardziej interesuje nas jaki obiekt ta funkcja wytworzyła. Wykorzystując <code>console.dir</code> mogę wypisać nazwę funkcji do konsoli i w ten sposób podejrzę obiekt, jaki tworzy. Również mógłbym przypisać po prostu funkcje do zmiennej i w ten sposób przechwycić ten obiekt:</p><div class="language-powershell ext-powershell line-numbers-mode"><pre class="language-powershell"><code>arguments: null\ncaller: null\nlength: 0\nname: <span class="token string">&quot;person&quot;</span>\nprototype: <span class="token punctuation">{</span>constructor: ƒ<span class="token punctuation">}</span>\n__proto__: ƒ <span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Okazuje się, że obiekt, który został stworzony przez funkcję, posiada wiele różnych właściwość związanych z funkcją, ale posiada także właściwość <code>prototype</code>, którą do tej pory mogliśmy zauważyć głównie tylko w obiektach wbudowanych jak <code>Object.prototype</code>, <code>Array.prototype</code> i tak dalej. Nigdy jednak, obiekty, które tworzyliśmy nie miały swojej właściwości <code>prototype</code>.</p><p>Nie mylmy jednak tej właściwości z właściwością <code>[[Prototype]]</code>, którą zapisuje się z dwoma nawiasami kwadratowymi i do której jest dostęp przez akcesor <code>__proto__</code>. Prototyp, który posłużył do stworzenia tego obiektu jest tutaj dostępny właśnie przez akcesor <code>__proto__</code> i pochodzi on z <code>Function.prototype</code>.</p><p>Wróćmy jednak do tej zwykłej właściwości <code>prototype</code>. Okazuje się, że tylko obiekty podtypu <code>Function</code> mają właściwość <code>prototype</code>, która jak wiemy, może być dziedziczona przez kolejne obiekty. Czyli ten obiekt może nam posłużyć do budowania innych obiektów.</p><p>Tak jak inne prototypy jak <code>Object.prototype</code>, <code>Array.prototype</code> i tak dalej, tak nasz prototyp <code>person.prototype</code> może również posłużyć do stworzenia innych obiektów. W ten sposób stworzyliśmy bazowy prototyp dla naszych własnych obiektów.</p><h2 id="wywołanie-konstruktora-funkcji" tabindex="-1"><a class="header-anchor" href="#wywołanie-konstruktora-funkcji" aria-hidden="true">#</a> Wywołanie konstruktora funkcji</h2><p>Wiemy już, że obiekty funkcyjne mają unikatową cechę w postaci właściwości <code>prototype</code>, możemy to zatem wykorzystać i tworzyć własne obiekty na bazie tego prototypu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">voice</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hrum hrum&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> animalObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&#39;Cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>animalObj<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Stworzyłem nową funkcję o nazwie <code>Animal</code>. Zauważcie, że tworzę w tej funkcji właściwości przez odwołanie się do <code>this</code>.</p><p>Tym razem również zmienna zaczyna się wielką literą. Jest to konwekcja, która powstała w środowisku JavaScript, aby funkcje lub wyrażenia funkcyjne, które będą tworzyć obiekty zapisywać wielką literą.</p><p>W JavaScript, obiekty możemy wywołać jako funkcje lub też możemy wywołać je z konstruktorem, czyli słówkiem <code>new</code>. Zawsze, gdy używamy <code>new</code>, wywołujemy konstruktor obiektu. Każdy obiekt wbudowany w JavaScript ma swój konstruktor jak <code>new String()</code>, <code>new Array()</code> czy nawet <code>new Object()</code>.</p><p>Gdy wywołamy <code>new</code> na obiekcie typu <code>Function</code> czyli naszym <code>Animal</code>, powstanie normalny obiekt, jaki znamy do tej pory, ale prototypem dla tego właśnie obiektu będzie <code>Animal.prototype</code>. Czyli nie jak do tej pory <code>Object.prototype</code> , <code>Array.prototype</code> czy <code>Function.prototype</code> tylko nasz stworzony prototyp obiektu.</p><div class="language-powershell ext-powershell line-numbers-mode"><pre class="language-powershell"><code>Animal <span class="token punctuation">{</span>name: <span class="token string">&quot;Cat&quot;</span><span class="token punctuation">,</span> voice: ƒ<span class="token punctuation">}</span>\nname: <span class="token string">&quot;Cat&quot;</span>\nvoice: ƒ <span class="token punctuation">(</span><span class="token punctuation">)</span>\n__proto__:\n\tconstructor: ƒ Animal<span class="token punctuation">(</span>name<span class="token punctuation">)</span>\n\t__proto__: Object\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Po wywołaniu funkcji z konstruktorem to, co było w <code>Animal.prototype</code> stało się wewnętrzną właściwością <code>[[Prototype]]</code> stworzonego właśnie obiektu. Stworzony <code>animalObject</code> ma akcesor <code>__proto__</code> prowadzący teraz do <code>Animal.prototype</code>. Oczywiście na końcu tego łańcuchu prototypów jest <code>Object.prototype</code>, ale wcześniej jest nasz ustalony <code>Animal.prototype</code>.</p><p>Obiekt, który został zwrócony przez <code>new Animal()</code> to zwykły obiekt JavaScript, taki sam jak tworzyliśmy do tej pory literalnie za pomocą nawiasów klamrowych, jednak jego podstawowym prototypem jest <code>Animal.prototype</code>, a nie <code>Object.prototype</code>. Jest to nowy typ <code>Animal</code>, który sami stworzyliśmy.</p><p>Co nam daje taka funkcjonalność? Przede wszystkim mając zdefiniowaną funkcję i wywołując ją z konstruktorem za pomocą słówka <code>new</code> możemy tworzyć kolejne obiekty w bardzo prosty sposób:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> animalObj2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&#39;Dog&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> animalObj3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">&#39;Mouse&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Obiekty te mają te same pola i te same metody. Otrzymujemy więc namiastkę klas, które znane są z języków obiektowych jak <code>Java</code>, <code>C++</code> czy <code>C#</code>. Dodatkowo obiekty te bazują na naszym stworzonym prototypie <code>Animal.prototype</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">Animal</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">run</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;running&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nanimalObj<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Możemy więc swobodnie modyfikować ten prototyp, dodawać nowe właściwości. Zmiany te będą dotyczyć tylko naszego stworzonego obiektu.</p><p>Ma to duża przewagę nad zwykłymi obiektami, które tworzyliśmy do tej pory literalnie i dziedziczyły one prototyp po <code>Objec.prototype</code>. Trudno jest tworzyć seryjnie obiekty o tych samych właściwościach w sposób literalny. Dodatkowo obiekty takie mają wtedy ogólny prototyp <code>Object.prototype</code>, którego lepiej nie modyfikować.</p><p>Ta właściwość funkcji była bardzo mocno wykorzystywana, zanim pojawiły się klasy w ESCMAScript 6. Dzisiaj w nowoczesnym kodzie raczej nie spotkacie się z tworzeniem obiektów w taki sposób. Obecnie wykorzystuje się klasy, które są trochę * syntactic sugar* dla tworzenia obiektów przy pomocy konstruktora funkcji. O klasach będzie zupełnie nowy dział.</p><p>Jednak to, co teraz widzimy to podstawy do zrozumienia klas i programowania obiektowego w JavaScript, które opiera się na prototypach i dziedziczeniu prototypowym.</p><h2 id="słowko-new-jest-bardzo-wazne" tabindex="-1"><a class="header-anchor" href="#słowko-new-jest-bardzo-wazne" aria-hidden="true">#</a> Słówko <code>new</code> jest bardzo ważne</h2><p>Gdy tworzymy funkcję, z której będziemy potem tworzyć obiekty za pomocą wywołania konstruktora, ważne jest, aby użyć słówko <code>new</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> car1 <span class="token operator">=</span> <span class="token function">Car</span><span class="token punctuation">(</span><span class="token string">&#39;Audi&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>car1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Audi</span>\n\n<span class="token keyword">const</span> car2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token string">&#39;Opel&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>car2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {name: &quot;Opel&quot;}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Mamy funkcję, która tworzy wewnętrzną właściwość przez <code>this.name</code>. Pierwszy przypadek wywołuje funkcję bez <code>new</code>. Funkcja ta zwraca <code>undefined</code>. Jeżeli nie użyliśmy <code>return</code> to funkcja zawsze zwraca sama z siebie <code>undefined</code> . Takie wywołanie nie tworzy nam też obiektu.</p><p>Nie jesteśmy także w <code>strict mode</code> dlatego w tym przypadku, <code>this</code> w funkcji wskazuje na obiekt <code>window</code>, z tego powodu nasze pole <code>model</code> znalazło się w obiekcie <code>window</code>. Gdybyśmy użyli trybu ścisłego w ogóle nie moglibyśmy wywołać funkcji bez słówka <code>new</code>. W trybie ścisłym <code>this</code> w funkcji wskazuje na <code>undefined</code>. I tak zapisana funkcja nie może zostać wywołana bez <code>new</code>.</p><p>Dlatego tak napisane funkcje powinniśmy wywoływać tylko z konstruktorem, czyli za pomocą <code>new</code>. Wtedy otrzymujemy nowy obiekt, a <code>this</code> jest odwołaniem do tego obiektu. Na szczęście używając trybu ścisłego, otrzymamy stosowne błędy informujące, że nie możemy wywoływać takich funkcji bez wywołania konstruktora.</p><h2 id="sprawdzanie-typu-przez-instanceof" tabindex="-1"><a class="header-anchor" href="#sprawdzanie-typu-przez-instanceof" aria-hidden="true">#</a> Sprawdzanie typu przez instanceof</h2><p>Użyliśmy do tej pory funkcji, potem wywoływaliśmy konstruktor tej funkcji i powstawał obiekt. Można się pogubić, co jest czym, dlatego warto sprawdzić sobie typy, które powstają w czasie tworzenia takich konstrukcji:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Book</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Book <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Book <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Book <span class="token keyword">instanceof</span> <span class="token class-name">Book</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Mamy funkcję <code>Book</code>, którą za chwilę będziemy wywoływać z konstruktorem. Za pomocą operatora <code>instanceof</code> mogę sprawdzić, do jakich typów należy konkretny obiekt. W tym przypadku porównując do typu <code>Function</code> otrzymujemy <code>true</code> ponieważ <code>Function.prototype</code> to pierwszy prototyp tej funkcji. Również otrzymujemy <code>true</code> gdy sprawdzamy, czy funkcja jest instancją <code>Object</code>. Każdy obiekt pochodzi z <code>Object.prototype</code>. Natomiast sama funkcja <code>Book</code> nie jest w żadne sposób związana z typem <code>Book</code>.</p><p>Gdy teraz wywołamy funkcję z konstruktorem, czyli de facto stworzymy nowy obiekt to wyniki mamy trochę inne:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> bookObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bookObject <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bookObject <span class="token keyword">instanceof</span> <span class="token class-name">Book</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bookObject <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Stworzony obiekt przy pomocy konstruktora funkcji nie jest już typem <code>Function</code>. Tak stworzony obiekt ma swój prototyp i jest teraz typu <code>Book</code> oraz jest typu <code>Object</code> jak każdy obiekt w JavaScript.</p><p>To nam pokazuje, że przy pomocy konstruktora funkcji jesteśmy w stanie tworzyć własne typy w JavaScript, to samo będziemy robili za pomocą klas.</p><p>Czasami też możecie się spotkać w Internecie ze sprawdzaniem typu za pomocą właściwości <code>constructor</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bookObject<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Book<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bookObject<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Każdy prototyp ma właściwość <code>constructor</code> i zostaje ona odziedziczona przez każdy obiekt. Właściwość ta dokładnie wskazuje, z jakiej funkcji wywołanej przez konstruktor powstał obiekt, w tym wypadku wskazuje dokładnie na <code>Book</code>. Gdy porównamy wartość konstruktora do <code>Object</code> otrzymujemy <code>false</code>, ponieważ konstruktor wskazuje tylko na jeden konkretny obiekt, który posłużył do konstrukcji.</p><p>Używanie konstruktora jednak może być czasami mylne, ponieważ może zostać nadpisany nawet przez programistę. Są to jednak już techniki, którymi nie musimy sobie zaprzątać głowy. Jeżeli chcemy sprawdzić dokładny typ obiektu, używajmy operatora <code>instanceof</code>.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>funkcje w JavaScript to obiekty</li><li>obiekty stworzone przez funkcje jako jedyne mają dodatkową właściwość <code>prototype</code></li><li>wykorzystując konstruktor funkcji, możemy tworzyć obiekty, które mają nasz własny prototyp jak <code>Book.prototype</code> , <code>Car.prototype</code></li><li>tylko wywołanie funkcji z konstruktorem, czyli z użyciem <code>new</code> stworzy obiekt z naszym własnym prototypem</li><li>do sprawdzania, z jakich typów został stworzony obiekt najlepiej użyć <code>instanceof</code></li></ul>',49),t={},p=(0,s(3744).Z)(t,[["render",function(n,a){const s=(0,o.up)("Comments");return(0,o.wg)(),(0,o.iD)(o.HY,null,[e,(0,o.Wm)(s)],64)}]])},3744:(n,a)=>{a.Z=(n,a)=>{for(const[s,o]of a)n[s]=o;return n}}}]);