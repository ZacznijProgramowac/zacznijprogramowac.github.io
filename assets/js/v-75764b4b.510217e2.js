"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[7226],{3606:(a,n,s)=>{s.r(n),s.d(n,{data:()=>e});const e={key:"v-75764b4b",path:"/zakresy-domkniecia-moduly/hoisting/",title:"Hoisting",lang:"pl-PL",frontmatter:{permalink:"/zakresy-domkniecia-moduly/hoisting"},excerpt:"",headers:[{level:2,title:"Przenoszenie deklaracji",slug:"przenoszenie-deklaracji",children:[]},{level:2,title:"Hoisting a funkcje",slug:"hoisting-a-funkcje",children:[]},{level:2,title:"Wyrażenie funkcji a hoisting",slug:"wyrazenie-funkcji-a-hoisting",children:[]},{level:2,title:"Hoisting przy const i let",slug:"hoisting-przy-const-i-let",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"zakresy-domkniecia-moduly/04-hoisting.md",git:{}}},9304:(a,n,s)=>{s.r(n),s.d(n,{default:()=>i});var e=s(6252);const o=(0,e.uE)('<h1 id="hoisting" tabindex="-1"><a class="header-anchor" href="#hoisting" aria-hidden="true">#</a> Hoisting</h1><p>Omawiając zakresy w JavaScript, trzeba jeszcze wspomnieć o bardzo ważnej rzeczy, którą jest hoisting. Jest to zagadnienie, które może zdziwić naprawdę wielu programistów.</p><p>Tylko dobry przykład może nam to zobrazować:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> a<span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Na początku do zmiennej <code>a</code> przypisuję wartość 42. Dopiero w kolejnej linii deklaruję zmienną <code>a</code>. W ostatniej linii wypisuję wartość.</p><p>Pytanie teraz jakiej wartości się spodziewacie? Czy to będzie <code>undefined</code>, błąd czy może po prostu <code>42</code></p><div class="language-powershell ext-powershell line-numbers-mode"><pre class="language-powershell"><code>42\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Odpowiedzią jest wartość 42. Jeżeli programujecie w innych językach programowania, prawdopodobnie spotkacie się z błędem, a JavaScript sobie z tym poradził.</p><p>Zobaczmy jeszcze jeden przykład, zanim zacznę tłumaczyć, dlaczego tak to działa w JavaScript:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// undefined</span>\n<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>W tym przykładzie staram się wypisać zmienną <code>b</code> do konsoli, a dopiero potem następuje deklaracja zmiennej <code>b</code>. Jak widzimy zmienna <code>b</code> ma wartość <code>undefined</code>, tak jakby była zadeklarowana wcześniej, ale bez przypisanej wartości. JavaScript znowu nie zgłasza w tym przypadku błędu. Wyjaśnijmy sobie, jak to działa.</p><h2 id="przenoszenie-deklaracji" tabindex="-1"><a class="header-anchor" href="#przenoszenie-deklaracji" aria-hidden="true">#</a> Przenoszenie deklaracji</h2><p>JavaScript wykonuje kompilację kodu, a dopiero potem go wykonuje. Gdy JavaScript dokonuje kompilacji kodu, wyszykuje między innymi wszystkie deklaracje zmiennych czy funkcje. Deklaracje, które zostają znalezione w czasie kompilacji kodu, są ustawiane na początku zakresu.</p><p>Przykład, który widzieliśmy:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> a<span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>zmienia postać na taką:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a<span class="token punctuation">;</span>\n\na <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Deklaracja w czasie kompilacji przeniesiona jest na początek zakresu, dlatego w czasie wykonywania kodu program wygląda już normalnie i nie zgłasza błędu o tym, że próbujemy przypisać wartość do zmiennej, która nie jest zadeklarowana.</p><p>Podobnie wygląda to z drugim przykładem:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// undefined</span>\n<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Po wykonaniu hoistingu kod wygląda tak:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> b<span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// undefined</span>\nb <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Tutaj także nastąpi najpierw deklaracja, potem wypisanie zmiennej i dopiero na końcu przypisanie wartości. Kompilator rozbije sobie tę jedną linię kodu, gdzie nastąpiła deklaracja z przypisaniem. Przeniesie deklarację na początek zakresu.</p><p>Patrząc na ten przykład jeszcze raz, widzimy, że kompilator rozdziela deklarację od przypisania zmiennej. Są to dla niego dwa różne działania. Deklaracje tworzone są w czasie kompilacji i są przenoszone na początek zakresu.</p><p>Dopiero w czasie wykonywania kodu następuje przypisanie do zmiennej wartości. I to jest bardzo ważna rzecz do rozróżnienia.</p><h2 id="hoisting-a-funkcje" tabindex="-1"><a class="header-anchor" href="#hoisting-a-funkcje" aria-hidden="true">#</a> Hoisting a funkcje</h2><p>Hoisting działa także w przypadku deklaracji funkcji:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;bar&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>W tym przykładzie wykonujemy funkcję <code>bar</code> przed jej zadeklarowaniem. JavaScript nie ma z tym żadnego problemu.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;bar&#39;</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Dzieje się tak, jak w przypadku zmiennych. Funkcja <code>bar</code> zostaje przeniesiona na początek zakresu jako deklaracja funkcji. Dlatego znowu JavaScript pozwala na wykonanie kodu, który jest zadeklarowany później.</p><h2 id="wyrazenie-funkcji-a-hoisting" tabindex="-1"><a class="header-anchor" href="#wyrazenie-funkcji-a-hoisting" aria-hidden="true">#</a> Wyrażenie funkcji a hoisting</h2><p>Trochę inaczej jest, gdy stworzymy wyrażenie funkcji:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>W takim przypadku czeka nas błąd, ponieważ w czasie hoistingu, deklaracja zmiennej <code>foo</code> zostanie przeniesiona na początek zakresu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> foo<span class="token punctuation">;</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// error</span>\n<span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Najpierw mamy deklarację funkcji, potem mamy jej wywołanie, a dopiero na końcu mamy jej przypisanie. Wyrażenie funkcji to tak naprawdę stworzenie zmiennej i proces hoistingu jest tutaj dokładnie taki sam.</p><h2 id="hoisting-przy-const-i-let" tabindex="-1"><a class="header-anchor" href="#hoisting-przy-const-i-let" aria-hidden="true">#</a> Hoisting przy const i let</h2><p>Do tej pory pokazywałem przykłady Hoistingu związane z deklaracją za pomocą <code>var</code>. Hoisting obejmuje także deklaracje za pomocą słów kluczowych <code>const</code> i <code>let</code>. Są tutaj jednak pewne różnice:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error</span>\n\n<span class="token keyword">var</span> x<span class="token punctuation">;</span>\n<span class="token keyword">let</span> z<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>W tym przykładzie jeszcze przed zadeklarowaniem zmiennych próbuję wypisać je do konsoli. Obie deklaracje podlegają pod hoisting i są przenoszone na początek zakresu.</p><p>Zmienna <code>x</code> jako zadeklarowana, ale nie mająca przypisanej wartości otrzymuje wartość <code>undefined</code>.</p><p>Zmienna <code>z</code>, także trafia na początek zakresu i jest zadeklarowana, jednak odwołanie się do niej nie jest możliwe. Zmienna ta znajduje się w Tymczasowej Martwej Strefie (TDZ - Temporal Dead Zone).</p><p>Zmienna przebywa tam tak długo, aż program w czasie wykonywania kodu natrafi na deklarację zmiennej <code>z</code>. Trzeba pamiętać, że nasz kod fizycznie nie zmienia się i jest wykonywany linia po linii. To, że następuje hoisting, nie oznacza, że fizycznie nasze zmienne przenoszone są na początek zakresu. Kod będzie wykonywał się tak, jak został zapisany.</p><p>Jednak przy zmiennych <code>var</code>, JavaScript nie czeka, aż napotka je w kodzie, jeżeli są deklaracje wyniesione przez hoisting, to następuje ich inicjalizacja.</p><p>Przy zmiennych <code>const</code> i <code>let</code>, je inicjalizacja oczekuje w Tymczasowej Martwej Strefie i gdy JavaScript przy wykonywaniu kodu natrafi na deklarację, to usuwa ją z Tymczasowej Martwej Strefy i dopiero wtedy tę deklarację wykonuje.</p><p>Tak naprawdę, można to wszystko sprowadzić do zdania, że nie możemy użyć zmiennych <code>const</code> i <code>let</code> przed ich deklaracją w kodzie, to odróżnia ich od zmiennej <code>var</code>.</p><p>Różnica w działaniu jest znaczna, a dzięki <code>const</code> i <code>let</code> możemy w kodzie zachować naturalny porządek.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>hoisting to przeniesienie deklaracji na początek zakresu kodu</li><li>w czasie kompilacji następuje deklaracja zmiennych</li><li>w czasie wykonania kodu następuje przypisanie wartości do zmiennych</li><li>hoisting dotyczy także funkcji</li><li>zmienne <code>const</code> i <code>let</code> podlegają pod hoisting, nie można się do nich odwołać przed deklaracją</li><li>z hoistingiem nie powinniśmy mieć problemów, gdy nie używamy <code>var</code></li></ul>',50),p={},i=(0,s(3744).Z)(p,[["render",function(a,n){const s=(0,e.up)("Comments");return(0,e.wg)(),(0,e.iD)(e.HY,null,[o,(0,e.Wm)(s)],64)}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[s,e]of n)a[s]=e;return a}}}]);