"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[1314],{7751:(a,n,s)=>{s.r(n),s.d(n,{data:()=>e});const e={key:"v-7748a79b",path:"/zakresy-domkniecia-moduly/use-strict/",title:"Use strict",lang:"pl-PL",frontmatter:{permalink:"/zakresy-domkniecia-moduly/use-strict"},excerpt:"",headers:[{level:2,title:"Dyrektywa use strict",slug:"dyrektywa-use-strict",children:[]},{level:2,title:"Zmienne muszą być zadeklarowane:",slug:"zmienne-musza-byc-zadeklarowane",children:[]},{level:2,title:"Nie można używać  delete do usuwania zmiennych, funkcji ani obiektów:",slug:"nie-mozna-uzywac-delete-do-usuwania-zmiennych-funkcji-ani-obiektow",children:[]},{level:2,title:"Zabronione jest duplikowanie parametrów funkcji i pól obiektów:",slug:"zabronione-jest-duplikowanie-parametrow-funkcji-i-pol-obiektow",children:[]},{level:2,title:"Dawniej liczby ósemkowe można było deklarować za pomocą zera z przodu liczby:",slug:"dawniej-liczby-osemkowe-mozna-było-deklarowac-za-pomoca-zera-z-przodu-liczby",children:[]},{level:2,title:"Nie można przypisywać wartości do natywnych właściwości języka:",slug:"nie-mozna-przypisywac-wartosci-do-natywnych-własciwosci-jezyka",children:[]},{level:2,title:"Przy pracy z obiektami, w trybie strict JavaScript zgłasza błędy, gdy próbujemy wykonać niedozwoloną operację:",slug:"przy-pracy-z-obiektami-w-trybie-strict-javascript-zgłasza-błedy-gdy-probujemy-wykonac-niedozwolona-operacje",children:[]},{level:2,title:"Zabronione jest przypisywanie wartości dla getterów:",slug:"zabronione-jest-przypisywanie-wartosci-dla-getterow",children:[]},{level:2,title:"Stworzenie nowego pola w obiekcie pomimo zakazu jego rozszerzania:",slug:"stworzenie-nowego-pola-w-obiekcie-pomimo-zakazu-jego-rozszerzania",children:[]},{level:2,title:"Próba usuwania wartości nieusuwalnych również zgłasza błąd:",slug:"proba-usuwania-wartosci-nieusuwalnych-rowniez-zgłasza-bład",children:[]},{level:2,title:"Nie można dodawać pól do wartości prymitywnych:",slug:"nie-mozna-dodawac-pol-do-wartosci-prymitywnych",children:[]},{level:2,title:"Zakaz używania słów kluczowych dla języka jako nazwy zmiennych:",slug:"zakaz-uzywania-słow-kluczowych-dla-jezyka-jako-nazwy-zmiennych",children:[]},{level:2,title:"W funkcjach zadeklarowanych globalnie this jest teraz undefined:",slug:"w-funkcjach-zadeklarowanych-globalnie-this-jest-teraz-undefined",children:[]},{level:2,title:"Eval oraz with",slug:"eval-oraz-with",children:[]},{level:2,title:"Czy i jak używać use strict",slug:"czy-i-jak-uzywac-use-strict",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"zakresy-domkniecia-moduly/05-use-strict.md",git:{}}},1691:(a,n,s)=>{s.r(n),s.d(n,{default:()=>t});var e=s(6252);const o=(0,e.uE)('<h1 id="use-strict" tabindex="-1"><a class="header-anchor" href="#use-strict" aria-hidden="true">#</a> Use strict</h1><p>JavaScript jest językiem, który musi zachowywać kompatybilność z kolejnymi wersjami. Oznacza to, że w JavaScript nie można wycofać zmian, które okazały się błędem. Głównym założeniem jest przede wszystkim zapewnienie działania tych skryptów, które zostały już napisane.</p><p>W wersji ES5 pojawiły się jednak pewne zmiany, których zadaniem było ulepszenie JavaScript. Zmiany te były standardowo wyłączone, więc nadal język zachowywał kompatybilność z innymi wersjami. Dano nam jednak możliwość decydowania o tym czy nasza aplikacja będzie używała wprowadzonych zmian i do tego powstała dyrektywa <code>&#39;use strict&#39;</code>. Można powiedzieć, że w ten sposób włączamy bezpieczniejszą i lepszą wersję JavaScript.</p><p>Włączenie tak po prostu trybu <code>strict</code> w starszym kodzie mógłby doprowadzić do zgłoszenia wielu błędów przez JavaScript i aplikacja nie działałaby dopóki nie wnieślibyśmy do niej kilku poprawek, które teraz sobie omówimy.</p><h2 id="dyrektywa-use-strict" tabindex="-1"><a class="header-anchor" href="#dyrektywa-use-strict" aria-hidden="true">#</a> Dyrektywa <code>use strict</code></h2><p>Dyrektywę <code>use strict</code> umieszczamy na początku pliku. Wszystko co znajduje się pod dyrektywą działa w trybie ścisłym:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token string">&#39;use strict&#39;</span><span class="token punctuation">;</span>\n\n<span class="token comment">/// some code</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Co ciekawe, możemy także użyć trybu ścisłego wewnątrz funkcji.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token string">&#39;use strict&#39;</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// ...your code here...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>W tym przypadku tryb <code>strict</code> włączony został tylko dla tej funkcji. Kod poniżej tej dyrektywy będzie musiał przestrzegać trybu ścisłego.</p><p>Należy pamiętać, że dyrektywa <code>use strict</code> musi być umieszczona na początku pliku lub funkcji:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>a <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>\n<span class="token comment">// no strict mode</span>\n\n<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>\nb <span class="token operator">=</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">;</span>\n<span class="token comment">// no strict mode</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bar</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Ten kod w ogóle nie działa w trybie ścisłym. Przed <code>use strict</code> nie możemy umieszczać żadnego kodu. Możemy umieszczać tylko komentarze.</p><p>Powyższy kod nie jest prawidłowy w trybie ścisłym, a jednak wykonuje się pomimo umieszczonej dyrektywy. Dzieje się tak, bo tryb ścisły nie został włączony. Deklaracja dla trybu ścisłego musi znaleźć się przed pierwszą linią kodu w skrypcie lub funkcji inaczej jest ignorowana.</p><h2 id="zmienne-musza-byc-zadeklarowane" tabindex="-1"><a class="header-anchor" href="#zmienne-musza-byc-zadeklarowane" aria-hidden="true">#</a> Zmienne muszą być zadeklarowane:</h2><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>name <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>\nx <span class="token operator">=</span> <span class="token punctuation">{</span> p1<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> p2<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Nie można używać zmiennych bez deklaracji <code>var</code>, <code>let</code> lub <code>const</code>. Zmienna deklarowana w taki sposób w jakimkolwiek miejscu w kodzie, od razu stawała się globalna. Na szczęście tryb ścisły ogranicza tą możliwość.</p><h2 id="nie-mozna-uzywac-delete-do-usuwania-zmiennych-funkcji-ani-obiektow" tabindex="-1"><a class="header-anchor" href="#nie-mozna-uzywac-delete-do-usuwania-zmiennych-funkcji-ani-obiektow" aria-hidden="true">#</a> Nie można używać <code>delete</code> do usuwania zmiennych, funkcji ani obiektów:</h2><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>a <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>\n<span class="token function-variable function">a1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span>\na3 <span class="token operator">=</span> <span class="token punctuation">{</span> o<span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">delete</span> a<span class="token punctuation">;</span>\n<span class="token keyword">delete</span> a1<span class="token punctuation">;</span>\n<span class="token keyword">delete</span> a3<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>W trybie ścisłym nie ma możliwości usuwania niezadeklarowanych zmiennych. Jeżeli istnieją z jakiegoś powodu, to nie można ich usuwać.</p><p>Nadal jednak można używać <code>delete</code> do usuwania wewnętrznych właściwości obiektu.</p><h2 id="zabronione-jest-duplikowanie-parametrow-funkcji-i-pol-obiektow" tabindex="-1"><a class="header-anchor" href="#zabronione-jest-duplikowanie-parametrow-funkcji-i-pol-obiektow" aria-hidden="true">#</a> Zabronione jest duplikowanie parametrów funkcji i pól obiektów:</h2><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token parameter">p1<span class="token punctuation">,</span> p1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> p<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> p<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Niestety taki kod gdzie mamy zduplikowane nazwy parametrów i pola obiektu jest poprawny w JavaScript. Dopiero tryb <code>strict</code> wyklucza możliwość stworzenia funkcji o dwóch takich samych parametrach.</p><h2 id="dawniej-liczby-osemkowe-mozna-było-deklarowac-za-pomoca-zera-z-przodu-liczby" tabindex="-1"><a class="header-anchor" href="#dawniej-liczby-osemkowe-mozna-było-deklarowac-za-pomoca-zera-z-przodu-liczby" aria-hidden="true">#</a> Dawniej liczby ósemkowe można było deklarować za pomocą zera z przodu liczby:</h2><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> octal <span class="token operator">=</span> <span class="token number">010</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Taka deklaracja jest niepoprawna, jak wiemy liczby ósemkowe zapisujemy z notacją zero i literką o:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> octal2 <span class="token operator">=</span> <span class="token number">0o10</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Dopiero taka deklaracja jest poprawna. Jednak przed trybem ścisłym można było zapisać deklarację tylko z zerem na początku.</p><h2 id="nie-mozna-przypisywac-wartosci-do-natywnych-własciwosci-jezyka" tabindex="-1"><a class="header-anchor" href="#nie-mozna-przypisywac-wartosci-do-natywnych-własciwosci-jezyka" aria-hidden="true">#</a> Nie można przypisywać wartości do natywnych właściwości języka:</h2><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> <span class="token number">Infinity</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>JavaScript jest tak elastycznym językiem, że można zrobić nawet takie cuda i nadpisać natywną wartość <code>undefined</code> czy <code>Infinity</code> i wiele innych. Teraz jest to zabronione i zgłaszany jest błąd.</p><h2 id="przy-pracy-z-obiektami-w-trybie-strict-javascript-zgłasza-błedy-gdy-probujemy-wykonac-niedozwolona-operacje" tabindex="-1"><a class="header-anchor" href="#przy-pracy-z-obiektami-w-trybie-strict-javascript-zgłasza-błedy-gdy-probujemy-wykonac-niedozwolona-operacje" aria-hidden="true">#</a> Przy pracy z obiektami, w trybie <code>strict</code> JavaScript zgłasza błędy, gdy próbujemy wykonać niedozwoloną operację:</h2><p>Zdefiniuję teraz pusty obiekt:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\nObject<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> <span class="token string">&#39;x&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> writable<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Za pomocą metody <code>defineProperty</code> deklaruję w obiekcie pole <code>x</code> oraz przypisuję mu wartość <code>0</code>, a także oznaczam, że pole to jest tylko do odczytu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>obj1<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Próbuję nadpisać wartość <code>x</code>. Pomimo tego, że wartość pola <code>x</code> nie zostanie nadpisana, to i tak JavaScript nie zgłaszał błędu. Teraz w trybie ścisłym jest zgłaszany błąd.</p><h2 id="zabronione-jest-przypisywanie-wartosci-dla-getterow" tabindex="-1"><a class="header-anchor" href="#zabronione-jest-przypisywanie-wartosci-dla-getterow" aria-hidden="true">#</a> Zabronione jest przypisywanie wartości dla getterów:</h2><p>Stworzymy sobie kolejny obiekt, z getterem:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token keyword">get</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token number">17</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Getter powinien tylko zwracać wartość:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>obj2<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>JavaScript traktuje metodę obiektu <code>obj2</code> jako pole tego obiektu i pozwala na zapis przypisania wartości. W trybie ścisłym taki zapis powoduje wyrzucenie błędu.</p><h2 id="stworzenie-nowego-pola-w-obiekcie-pomimo-zakazu-jego-rozszerzania" tabindex="-1"><a class="header-anchor" href="#stworzenie-nowego-pola-w-obiekcie-pomimo-zakazu-jego-rozszerzania" aria-hidden="true">#</a> Stworzenie nowego pola w obiekcie pomimo zakazu jego rozszerzania:</h2><p>Tworzę obiekt, i za pomocą metody <code>preventExtensions</code>, oznaczam, że obiekt nie może być rozszerzony o nowe pola:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> obj3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\nObject<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span>obj3<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Mogę jednak spróbować dodać nowe pole.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>obj3<span class="token punctuation">.</span>newProp <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Do tej pory wykonanie takich operacji i tak nie miało żadnego skutku, ale też nie zgłaszało błędu. Wydawało się więc, że kod jest poprawny. Teraz JavaScript zgłasza wyjątki w trybie <code>strict</code>.</p><h2 id="proba-usuwania-wartosci-nieusuwalnych-rowniez-zgłasza-bład" tabindex="-1"><a class="header-anchor" href="#proba-usuwania-wartosci-nieusuwalnych-rowniez-zgłasza-bład" aria-hidden="true">#</a> Próba usuwania wartości nieusuwalnych również zgłasza błąd:</h2><p>Można było użyć <code>delete</code> do usuwania predefiniowanych właściwości języka:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">delete</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Mogliśmy stworzyć zapis, który usuwa <code>prototype</code> z globalnego obiektu <code>Object</code>. Chociaż kod te nie miał efektu, to nie zgłaszał też żadnego błędu. Teraz otrzymujemy wyjątek.</p><h2 id="nie-mozna-dodawac-pol-do-wartosci-prymitywnych" tabindex="-1"><a class="header-anchor" href="#nie-mozna-dodawac-pol-do-wartosci-prymitywnych" aria-hidden="true">#</a> Nie można dodawać pól do wartości prymitywnych:</h2><p>Do obiektu <code>false</code> dodaje pole <code>true</code>, lub do literału <code>41</code> dodaje pole <code>name</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token boolean">false</span><span class="token punctuation">.</span><span class="token boolean">true</span> <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>\n<span class="token punctuation">(</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;boo&#39;</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Przy takich dziwnych zapisach przed trybem <code>strict</code> JavaScript nie zgłaszał żadnych błędów. Dla trybu <code>strict</code> takie zapisy nie są już możliwe.</p><h2 id="zakaz-uzywania-słow-kluczowych-dla-jezyka-jako-nazwy-zmiennych" tabindex="-1"><a class="header-anchor" href="#zakaz-uzywania-słow-kluczowych-dla-jezyka-jako-nazwy-zmiennych" aria-hidden="true">#</a> Zakaz używania słów kluczowych dla języka jako nazwy zmiennych:</h2><p>Kolejną dziwną sytuacją bez trybu ścisłego jest możliwość zadeklarowania zmiennej o nazwie <code>let</code> albo <code>public:</code></p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token keyword">let</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> <span class="token keyword">public</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Poza trybem <code>strict</code> można było używać niektórych słów kluczowych do deklaracji zmiennych. W specyfikacji istnieje teraz lista słów, które są ważne dla języka i będą istotne w przyszłości, są teraz zabronione.</p><h2 id="w-funkcjach-zadeklarowanych-globalnie-this-jest-teraz-undefined" tabindex="-1"><a class="header-anchor" href="#w-funkcjach-zadeklarowanych-globalnie-this-jest-teraz-undefined" aria-hidden="true">#</a> W funkcjach zadeklarowanych globalnie <code>this</code> jest teraz <code>undefined</code>:</h2><p>Gdy tworzyliśmy funkcję, mogliśmy się odwołać w niej do globalnego obiektu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// undefined in strict mode</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Poza trybem <code>strict</code> w funkcji przez <code>this</code> mieliśmy dostęp do globalnego obiektu. W przeglądarce był to obiekt <code>window</code> . Teraz <code>this</code> w funkcji zwraca <code>undefined</code>.</p><h2 id="eval-oraz-with" tabindex="-1"><a class="header-anchor" href="#eval-oraz-with" aria-hidden="true">#</a> Eval oraz with</h2><p>Dodatkowo tryb <code>strict</code> reguluje funkcję <code>eval</code> oraz instrukcję <code>with</code>. Jednak tego tematu już nie będę omawiał. Raczej nie powinniśmy używać tych właściwości języka JavaScript w naszym kodzie.</p><p>Poznaliśmy kilka przypadków, w których JavaScript działał naprawdę dziwnie i poza wszelką intuicją. Tryb <code>strict</code> wymusza poprawne działanie i zgłaszanie wyjątków w sytuacjach, kiedy powinny być zgłoszone. Język w tym trybie jest czytelniejszy i bezpieczniejszy.</p><h2 id="czy-i-jak-uzywac-use-strict" tabindex="-1"><a class="header-anchor" href="#czy-i-jak-uzywac-use-strict" aria-hidden="true">#</a> Czy i jak używać <code>use strict</code></h2><p>Czy zawsze powinniśmy używać trybu <code>strict</code>. Krótka odpowiedź brzmi jak najbardziej. Chroni to nas przed popełnieniem błędu i sam kod jest o wiele bardziej bezpieczny. Są jednak wyjątki, w których nie musimy używać tej dyrektywy.</p><ul><li>klasy JavaScript domyślnie pracują w trybie <code>strict</code></li><li>moduły ES6 w JavaScript także domyślnie pracują w trybie <code>strict</code></li><li>w żadnym nowoczesnym frameworku nie potrzebujesz włączać <code>use strict</code></li></ul><p>Pisząc dzisiaj nowoczesny kod w JavaScript, gdzie używa się frameworków, modułów ES6 i klas nie musimy dopisywać na początku naszego pliku <code>use strict</code>.</p><p>Jeśli jednak pracujesz z bardzo starym kodem lub po prostu używasz Vanilla JS i nie używasz modułów, klas to włączenie tego trybu pomoże Ci pisać lepszy kod.</p><p>Ja tworząc przykłady dla tego kursu, nie używam trybu <code>strict</code>, głównie po to, aby Wam pokazać pełne działanie JavaScript.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li><p>tryb ścisły reguluje i poprawia błędy JavaScript</p></li><li><p>aby zachować kompatybilność języka ze starymi aplikacjami, tryb ten nie jest domyślny</p></li><li><p>klasy JavaScript domyślnie pracują w trybie <code>strict</code></p></li><li><p>moduły ES6 w JavaScript także domyślnie pracują w trybie <code>strict</code></p></li><li><p>w żadnym nowoczesnym frameworku nie potrzebujesz włączać <code>use strict</code></p></li></ul>',77),i={},t=(0,s(3744).Z)(i,[["render",function(a,n){const s=(0,e.up)("Comments");return(0,e.wg)(),(0,e.iD)(e.HY,null,[o,(0,e.Wm)(s)],64)}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[s,e]of n)a[s]=e;return a}}}]);