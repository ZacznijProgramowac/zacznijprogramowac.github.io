"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[2450],{717:(a,n,o)=>{o.r(n),o.d(n,{data:()=>e});const e={key:"v-448fa184",path:"/prototypy/nadpisywanie-metod-prototypu/",title:"Nadpisywanie metod prototypu",lang:"pl-PL",frontmatter:{permalink:"/prototypy/nadpisywanie-metod-prototypu"},excerpt:"",headers:[{level:2,title:"Nadpisanie metody odziedziczonej",slug:"nadpisanie-metody-odziedziczonej",children:[]},{level:2,title:"Zmiana metod w prototypie",slug:"zmiana-metod-w-prototypie",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"prototypy/03-nadpisywanie-metod-prototypu.md",git:{}}},3543:(a,n,o)=>{o.r(n),o.d(n,{default:()=>s});const e=(0,o(6252).uE)('<h1 id="nadpisywanie-metod-prototypu" tabindex="-1"><a class="header-anchor" href="#nadpisywanie-metod-prototypu" aria-hidden="true">#</a> Nadpisywanie metod prototypu</h1><p>Prototypy wbudowanych obiektów JavaScript zapewniają wiele metod i właściwości. Zazwyczaj wykorzystujemy je tak jak zostały zaprojektowane. Czasami jednak potrzebujemy zmienić zachowanie takiej metody.</p><h2 id="nadpisanie-metody-odziedziczonej" tabindex="-1"><a class="header-anchor" href="#nadpisanie-metody-odziedziczonej" aria-hidden="true">#</a> Nadpisanie metody odziedziczonej</h2><p><code>Object.prototype</code> ma wbudowaną metodę <code>toString()</code>. Metoda ta jest bardzo często nadpisywana przez inne obiekty jak <code>Array</code>, w <code>Array.prototype</code> jest własna implementacja <code>toString()</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1, 2, 3</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Wywołując <code>toString()</code> na tablicy, otrzymujemy wartość tablicy w formie tekstu. Każdy element tablicy dodatkowo oddzielony jest przecinkiem.</p><p>Gdy stworzymy swój własny obiekt, sytuacja wygląda zupełnie inaczej:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n  surname<span class="token operator">:</span> <span class="token string">&#39;Rambo&#39;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Object]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Otrzymujemy dziwny zapis, który tak naprawdę informuje nas o tym, że metoda ta została wywołana z obiektu o typie Object. Możemy to poprawić i dodać własną implementację metody <code>toString()</code> do naszego obiektu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>obj<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">&#39; &#39;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>surname<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John Rambo</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Dodaję do stworzonego obiektu nową metodę <code>toString()</code>. Tym sposobem nadpisuję metodę, która została odziedziczona z <code>Object.prototype</code>. Od tego momentu, gdy wywołam <code>toString()</code> na moim obiekcie, metoda zwróci dokładnie to co zaimplementowałem. Dokładnie tak samo działa to w przypadku tablic, <code>Array.prototype</code> nadpisuje metodę <code>toString</code> pochodzącą z <code>Object.prototype</code>.</p><p>Ten proces nazywamy nadpisaniem lub przysłonięciem metod odziedziczonych. W ten sposób oczywiście możemy nadpisać wszystkie odziedziczone metody w naszym obiekcie. Ważne jest to, że to nadpisanie dotyczy tylko naszego obiektu. Gdy stworzymy nowy obiekt, będziemy musieli w nim znowu nadpisać metodę <code>toString()</code>.</p><h2 id="zmiana-metod-w-prototypie" tabindex="-1"><a class="header-anchor" href="#zmiana-metod-w-prototypie" aria-hidden="true">#</a> Zmiana metod w prototypie</h2><p>Posłużyłem się wcześnie przykładem tablicy i pokazałem, że tam metoda <code>toString()</code> działa zupełnie inaczej niż ta pochodząca z <code>Object.prototype</code>, ponieważ została nadpisana. W dodatku działa tak dla każdej stworzonej tablicy. Natomiast moja metoda <code>toString()</code>, którą stworzyłem w obiekcie, działa tylko dla tego obiektu.</p><p>Jest jednak możliwość nadpisania metody <code>toString()</code> dla każdego obiektu:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>const obj2 = {\n  name: &#39;John&#39;,\n};\n\nObject.prototype.toString = function () {\n  return &#39;foo&#39;;\n};\n\nconst obj3 = {\n  name: &#39;Rambo&#39;,\n};\n\nconsole.log(obj2.toString()); // foo\nconsole.log(obj3.toString()); // foo\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>W tym przykładzie odwołuję się do <code>Object.prototype</code> i do metody <code>toString</code>, którą nadpisuję własną funkcją. Takie nadpisanie metody w <code>Object.prototype</code>, powoduje globalną zmianę w całej aplikacji. Nie jest to istotne czy zmiana prototypu nastąpiła po deklaracji jakiegoś obiektu. Każdy obiekt współdzieli dostęp do tego samego <code>Object.prototype</code> i zmiana ta dotyka każdego obiektu.</p><p>Teraz wywołując metodę <code>toString()</code> na obiektach, wywołuję funkcję, którą przypisałem do <code>Object.prototype.toString</code>. Natomiast nasz poprzedni obiekt, w którym została nadpisana metoda <code>toString()</code> dalej korzysta ze swojej metody, ponieważ w tamtym obiekcie nastąpiło przysłonięcie metody z <code>Object.prototype</code>.</p><p>Do prototypu <code>Object.prototype</code> możemy również dodawać nowe własne metody. W ten sposób możemy wszystkim obiektom w aplikacji dopisać całkowicie nową metodę. Modyfikacja prototypów jest potężnym narzędziem. Należy bardzo ostrożnie podchodzić do modyfikowania prototypów, albo najlepiej nie robić tego wcale.</p><p>Prototypy globalnych obiektów modyfikowane zazwyczaj są przez skrypty polyfills lub specjalistyczne biblioteki. W naszym kodzie powinniśmy zrobić wszystko, aby uniknąć modyfikacji prototypu. Taka globalna zmiana jest niebezpieczna i można łatwo wpaść w konflikt nazw z innymi bibliotekami, które wykorzystują wbudowane prototypy.</p><p>Możemy również zmieniać prototypy każdego globalnego obiektu jak <code>String.prototype</code>, <code>Array.prototype</code> i inne. Wtedy zmiany te dotykają konkretnych typów. To właśnie najczęściej skrypty polyfills dodają do konkretnych typów nowe funkcjonalności, które jeszcze nie są wspierane przez przeglądarki, a znajdują się już w specyfikacji JavaScript.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>metody, które są w prototypach możemy nadpisywać w swoich obiektach</li><li>możemy globalnie zmieniać implementacje metod przez modyfikację w prototypie, na przykład możemy zmienić metodę <code>Object.prototype.toString</code></li><li>zmiana w prototypie wpływa od razu na wszystkie obiekty w aplikacji</li><li>inne globalne obiekty jak <code>Array</code>, <code>String</code>, <code>Number</code> mają swoje prototypy, które często nadpisują funkcjonalności z <code>Object.prototype</code></li></ul>',23),t={},s=(0,o(3744).Z)(t,[["render",function(a,n){return e}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[o,e]of n)a[o]=e;return a}}}]);