"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[4344],{5388:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-28eb3f71",path:"/obiekty/metody-obiektow/",title:"Metody w obiektach",lang:"pl-PL",frontmatter:{permalink:"/obiekty/metody-obiektow"},excerpt:"",headers:[{level:2,title:"Metody w obiektach JavaScript",slug:"metody-w-obiektach-javascript",children:[]},{level:2,title:"Getter i setter",slug:"getter-i-setter",children:[]},{level:2,title:"Metoda jako arrow function",slug:"metoda-jako-arrow-function",children:[]},{level:2,title:"Skrótowy zapis metody",slug:"skrotowy-zapis-metody",children:[]},{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"obiekty/02-metody-obiektow.md",git:{}}},1431:(n,a,s)=>{s.r(a),s.d(a,{default:()=>t});const e=(0,s(6252).uE)('<h1 id="metody-w-obiektach" tabindex="-1"><a class="header-anchor" href="#metody-w-obiektach" aria-hidden="true">#</a> Metody w obiektach</h1><p>Do tej pory zapoznaliśmy się z obiektami które przetrzymywały typy prymitywne. Jak już wspomniałem do pól w obiekcie przypisać możemy każdy typ danych. Przede wszystkim możemy używać funkcje, które przypisane do pola w obiekcie nazywamy metodami.</p><h2 id="metody-w-obiektach-javascript" tabindex="-1"><a class="header-anchor" href="#metody-w-obiektach-javascript" aria-hidden="true">#</a> Metody w obiektach JavaScript</h2><p>Metody w obiektach JavaScript mogą być zapisane na różne sposoby. Zobaczmy pierwszy sposób:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">print</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nobj1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&#39;Hello&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;Hello&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>W tym przypadku widzimy obiekt z polem <code>print</code>. Jego wartością jest przypisana <code>funkcja</code>. Funkcję przypisujemy tak samo jakbyśmy przypisali wartość prymitywną. Funkcje, które znajdują się w obiektach zazwyczaj będziemy nazywamy metodami.</p><p>Oczywiście nic nie stoi na przeszkodzie, aby do obiektu dodawać kolejne metody, podobnie jak przy dodawaniu zwykłych pól:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>obj1<span class="token punctuation">.</span><span class="token function-variable function">printError</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nobj1<span class="token punctuation">.</span><span class="token function">printError</span><span class="token punctuation">(</span><span class="token string">&#39;Some error&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;Some rror&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Nie ma różnicy między dopisaniem metody do obiektu a dopisaniem zwykłej wartości prymitywnej. Postępujemy dokładnie tak samo.</p><p>Jednak metody mogą o wiele więcej niż zwykłe wartości prymitywne. W metodzie możemy na przykład odwołać się do pola w obiekcie i jest to częsta praktyka:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n  <span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nperson<span class="token punctuation">.</span><span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Mamy zdefiniowany obiekt w którym znajduje się pole <code>name</code> oraz metoda <code>printName</code>. Zadaniem metody jest wydrukowanie danych do konsoli. Zauważ, że do pola <code>name</code> odnosimy się przez słowo kluczowe <code>this</code>. Bez tego metoda <code>printName</code> nie będzie wstanie zlokalizować pola <code>name</code>.</p><p>Samo <code>this</code> w JavaScript może być na tyle problematyczne, że będzie omówione dokładnie w oddzielnym dziale. Dla uproszczenia powiem, że słowo <code>this</code> wskazuje na ten obiekt i w tym obiekcie będzie poszukiwane pole <code>name</code>.</p><h2 id="getter-i-setter" tabindex="-1"><a class="header-anchor" href="#getter-i-setter" aria-hidden="true">#</a> Getter i setter</h2><p>W JavaScript istnieją jeszcze specjalne metody jak <code>get</code> i <code>set</code>, które możemy zdefiniować w obiekcie. Nazywane są też akcesorami i często mówi się o nich jako <code>getter</code> i <code>setter</code>.</p><p><code>Getter</code> jest metodą, która zwraca wartość konkretnego pola, a <code>setter</code> metodą, która ustawia wartość konkretnego pola:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  firstName<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> name<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>W tym obiekcie mamy zdefiniowane pole <code>firstName</code> oraz akcesory do tego pola. Pierwszym akcesorem jest <code>get</code>. Konstrukcja jest nieco inna niż tworzenie metody. Używamy instrukcji <code>get</code> po czym następuje stworzenie nazwy gettera.</p><p>Podobnie jest z akcesorem <code>set</code>. Po instrukcji <code>set</code> tworzymy metodę, która musi przyjąć dokładnie jeden parametr. Nie możemy stworzyć <code>settera</code> bez parametrów, albo z większą ilością niż jeden parametr.</p><p>Gdy tworzymy <code>getter</code> i <code>setter</code> dla konkretnego pola w obiekcie, zawsze tworzymy taką samą nazwę. W przypadku <code>gettera</code> i <code>settera</code> nie jest to problem, że oba <code>accessory</code> posiadają identyczną nazwę.</p><p><code>Getter</code> i <code>setter</code> obsługuje się tak samo jak pola w obiekcie:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;Rambo&#39;</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;Rambo&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Nie wywołujemy <code>settera</code> o nazwie <code>name</code> i nie przekazujemy mu parametru, korzystamy z niego identycznie jak z pola w klasie.</p><p>To samo dotyczy wywołania <code>gettera</code>, nie są potrzebna okrągłe nawiasy na końcu jak do wywołania metody. Po prostu odwołujemy się do <code>gettera</code> jak do pola w klasie.</p><p>Akcesory mogą być przydatne gdy bardziej chcemy kontrolować dane zapisywane do określonego pola. Jeśli mamy potrzebę w jakiś sposób kontrolować pole w klasie możemy zrobić to z getterem i setterem:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  _name<span class="token operator">:</span> <span class="token string">&#39;Rambo&#39;</span><span class="token punctuation">,</span>\n  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>W JavaScript jest konwencja w której podkreślenie przy nazwie pola oznacza, że to pole jest prywatne i nie należy odwoływać się do niego bezpośrednio. W JavaScript do tej pory prywatne pola nie istniały. Jest propozycja ich dodania i być może będziemy mogli ich oficjalnie używać w przyszłości.</p><p>Dlatego często używa się zapisu pola z podkreśleniem oraz stworzeniem <code>gettera</code> i <code>settera</code> ale już o normalnej nazwie. Korzystając z tego obiektu będziemy używać <code>accessorów</code> jak normalnego pola obiektu, a pole z podkreśleniem powinno być przez nas omijane.</p><p>Dodatkowo <code>getter</code> i <code>setter</code> pozwala nam na dodanie dodatkowej logiki. Możemy w jakiś sposób modyfikować przychodzące i wychodzące wartości.</p><p>Pamiętajmy, że akcesory nie zastąpią nam metod w obiektach i nie należy nimi tego robić. Akcesory jak sama nazwa wskazuje, mają dać nam dostęp do danych obiektu. Metody natomiast mogą pełnić różne funkcje w obiekcie.</p><h2 id="metoda-jako-arrow-function" tabindex="-1"><a class="header-anchor" href="#metoda-jako-arrow-function" aria-hidden="true">#</a> Metoda jako arrow function</h2><p>W obiektach możemy także definiować obiekty jako <code>arrow function</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> person3 <span class="token operator">=</span> <span class="token punctuation">{</span>\n    firstName<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">print</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\nperson3<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Tworzenie metod jako <code>arrow function</code> w obiektach może być atrakcyjne, jednak nie jest to zalecane. Pojawia się tu problem z <code>this</code>, który nie odwołuje się tutaj do obiektu w którym istnieje metoda, ale w tym przypadku do obiektu globalnego <code>window</code> jeśli mówimy o przeglądarce. O <code>this</code> i problemach tego typu będziemy rozmawiać w oddzielnym dziale.</p><p>Dobrą radą natomiast jest nie używanie <code>arrow functions</code> w obiektach JavaScript.</p><h2 id="skrotowy-zapis-metody" tabindex="-1"><a class="header-anchor" href="#skrotowy-zapis-metody" aria-hidden="true">#</a> Skrótowy zapis metody</h2><p>W ES6 pojawił się nowy sposób zapisu metod w obiektach JavaScript:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> person4 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  firstName<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nperson4<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#39;John&#39;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>W tym zapisie tworzymy po prostu nazwę funkcji bez słowa kluczowego <code>function</code>. Nie musimy też przypisywać funkcji do pola w obiekcie. Wyglądem przypomina <code>setter</code> i <code>getter</code>. Jest to obecnie dość często stosowany zapis metody w obiektach. Zdecydowanie zmniejsza ilość kodu i poprawia czytelność.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li><p>możemy przypisać funkcję do pola w obiekcie, wtedy staje się ona metodą</p></li><li><p>obiekty mogą posiadać akcesory jak <code>getter</code> i <code>setter</code></p></li><li><p>nie należy używać <code>arrow function</code> jako metod w obiektach</p></li><li><p>istnieje skrótowy zapis metod w obiektach wprowadzony w ES6</p></li></ul>',41),o={},t=(0,s(3744).Z)(o,[["render",function(n,a){return e}]])},3744:(n,a)=>{a.Z=(n,a)=>{for(const[s,e]of a)n[s]=e;return n}}}]);