"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[7698],{5057:(a,n,s)=>{s.r(n),s.d(n,{data:()=>e});const e={key:"v-5e7c8056",path:"/zakresy-domkniecia-moduly/zakres-blokow/",title:"Zakres blokowy",lang:"pl-PL",frontmatter:{permalink:"/zakresy-domkniecia-moduly/zakres-blokow"},excerpt:"",headers:[{level:2,title:"Co warto zapamiętać",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"zakresy-domkniecia-moduly/02-zakres-blokowy.md",git:{}}},7853:(a,n,s)=>{s.r(n),s.d(n,{default:()=>c});const e=(0,s(6252).uE)('<h1 id="zakres-blokowy" tabindex="-1"><a class="header-anchor" href="#zakres-blokowy" aria-hidden="true">#</a> Zakres blokowy</h1><p>Kolejnym zakresem, który sobie omówimy jest zakres blokowy. Przed wersją <code>ES6</code> zakres blokowy praktycznie nie istniał, zobaczmy najprostszy przypadek kodu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>\n  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">&#39;1&#39;</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token string">&#39;2&#39;</span><span class="token punctuation">;</span>\n  <span class="token keyword">let</span> z <span class="token operator">=</span> <span class="token string">&#39;3&#39;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Stworzyłem blok za pomocą dwóch nawiasów klamrowych. Tworzenie takich bloków kodu jest możliwe, ale raczej na co dzień nie spotkacie się z takimi blokami kodu w aplikacjach JavaScript.</p><p>Gdy wypiszemy te zmienne do konsoli:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>\n<span class="token comment">// console.log(y); // error</span>\n<span class="token comment">// console.log(z); // error</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Widzimy, że mamy dostęp tylko do zmiennej <code>x</code> natomiast pozostałe zmienne, które zadeklarowane są za pomocą <code>const</code> i <code>let</code> nie są dostępne. Oznacza to, że zmienne zadeklarowane za pomocą <code>var</code> nie respektują zakresu blokowego. Zmienna <code>var</code> w tym przypadku jest zadeklarowana globalnie w obiekcie <code>window</code>. Zakres bloku nie ma dla niej znaczenia.</p><p>Naprawiono to dopiero w ESCMAScript 6 wprowadzając deklaracje <code>const</code> i <code>let</code>.</p><p>Oczywiście takiego kodu blokowego raczej nie piszemy, a jak już używamy <code>let</code> i <code>const</code>. Jednak warto zwrócić uwagę, że z <code>var</code> są także problemy w innych blokach kodu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 1, 2, 3, 4</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// 5</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Jest to jeden z najbardziej znanych przykładów braku zakresu bloku dla zmiennych <code>var</code>. Zadeklarowana zmienna <code>var</code> na potrzeby funkcji nadal była dostępna spoza tego bloku. Programista przez nieuwagę w dalszej części mógł jeszcze raz użyć zmiennej <code>i</code>. Rozwiązaniem jest tutaj użycie deklaracji <code>let</code>.</p><p>Problemy te dotyczą oczywiście innych instrukcji blokowych jak <code>if</code>, <code>while</code> :</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>\n<span class="token comment">// console.log(b) // error</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Tutaj nadal mamy dostęp do zmiennej <code>a</code> zadeklarowanej w bloku <code>if</code>. Dlatego najlepszą opcją jest nieużywanie zmiennych deklarowanych za pomocą <code>var</code>. Dla tych zmiennych zakres blokowy nie istnieje i wpadają one zawsze do obiektu globalnego i są dostępne globalnie.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać</h2><ul><li>zmienna <code>var</code> nie przestrzega zakresu blokowego, używanie <code>var</code> w blokach jest jednoznaczne z tworzeniem zmiennych globalnych</li><li>dopiero <code>let</code> i <code>const</code> wprowadzone w ECMAScript 6 przestrzegają zakresu blokowego, między innymi takich jak <code>if</code> oraz <code>for</code></li><li>dobra rada nie używamy <code>var</code></li></ul>',16),o={},c=(0,s(3744).Z)(o,[["render",function(a,n){return e}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[s,e]of n)a[s]=e;return a}}}]);