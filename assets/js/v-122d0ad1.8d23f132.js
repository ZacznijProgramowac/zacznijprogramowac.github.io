"use strict";(self.webpackChunkkurs_javascript=self.webpackChunkkurs_javascript||[]).push([[6844],{3477:(a,n,o)=>{o.r(n),o.d(n,{data:()=>e});const e={key:"v-122d0ad1",path:"/prototypy/petla-for/",title:"Łańcuch prototypów i własne prototypy",lang:"pl-PL",frontmatter:{permalink:"/prototypy/petla-for"},excerpt:"",headers:[{level:2,title:"Wywołanie łańcucha prototypów",slug:"wywołanie-łancucha-prototypow",children:[]},{level:2,title:"Stworzenie własnego prototypu",slug:"stworzenie-własnego-prototypu",children:[]},{level:2,title:"Co warto zapamiętać:",slug:"co-warto-zapamietac",children:[]}],filePathRelative:"prototypy/02-lancuch-prototypow.md",git:{}}},3168:(a,n,o)=>{o.r(n),o.d(n,{default:()=>t});const e=(0,o(6252).uE)('<h1 id="łancuch-prototypow-i-własne-prototypy" tabindex="-1"><a class="header-anchor" href="#łancuch-prototypow-i-własne-prototypy" aria-hidden="true">#</a> Łańcuch prototypów i własne prototypy</h1><p>W JavaScript jest możliwość dziedziczenia po wielu prototypach obiektów. Przykładem jest tablica, która otrzymuje prototyp z <code>Array.prototype</code>, a sam <code>Array.prototype</code> ma prototyp z <code>Object.prototype</code>. Dodatkowo można tworzyć własne obiekty, po których można odziedziczyć prototyp. Zobaczmy z czym to się wiąże.</p><h2 id="wywołanie-łancucha-prototypow" tabindex="-1"><a class="header-anchor" href="#wywołanie-łancucha-prototypow" aria-hidden="true">#</a> Wywołanie łańcucha prototypów</h2><p>Gdy tworzymy nowy obiekt, dziedziczymy dla tego obiektu właściwości z <code>Object.prototype</code>. Nie są one widoczne bezpośrednio w naszym obiekcie, ale JavaScript potrafi je odnaleźć w odziedziczonym prototypie:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Object]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Mamy stworzony obiekt, który nie ma zaimplementowanej metody <code>toString()</code>. Możemy jednak wywołać na naszym obiekcie metodę <code>toString()</code>. Co prawda, nie zwraca ona zbyt ciekawej wartości, ale jednak działa.</p><p>Jeżeli wywołujemy jakaś metodę lub odwołujemy się do jakiegoś pola w obiekcie, JavaScript na początku poszukuje tych właściwości w obiekcie, na którym występuje wywołanie. Jeżeli nie znajdzie tych właściwości w tym obiekcie, przeszukuje odziedziczony prototyp. Jeżeli uda się odnaleźć metodę to zostanie ona użyta dla naszego obiektu. Jeżeli nie, to będzie zwrócona wartość <code>undefined</code>.</p><p>Widzieliśmy już na przykładzie tablicy, że dziedziczonych prototypów może być więcej:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1,2,3</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span>\n\n<span class="token comment">// arr -&gt; Array.prototype -&gt; Object.prototype</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Gdy stworzymy tablicę w JavaScript to tablica dziedziczy z <code>Array.prototype</code>. Z kolei <code>Array.prototype</code> dziedziczy z <code>Object.prototype</code>. Nasza tablica posiada właściwość <code>__proto__</code>, która zwraca pierwszy prototyp z <code>Array.prototype</code>. Ten prototyp, także ma właściwość <code>__proto__</code> i on zwraca prototyp z <code>Object.prototype</code>. Stworzył się tutaj łańcuch prototypów.</p><p>Metoda <code>toString()</code> nie istnieje bezpośrednio w naszym obiekcie. JavaScript przeszukuje <code>__proto__</code> i szuka metody <code>toString()</code> okazuje się, że znalazł ją i jest ona odziedziczona po <code>Array.prototype</code>. Wywołuje i kończy przeszukiwanie.</p><p>W drugim przypadku metoda <code>valueOf</code> nie zostaje znaleziona w pierwszym <code>[[Prototype]]</code> czyli tym pochodzącym od <code>Array.prototype</code>. JavaScript idzie głębiej i wywołuje drugą właściwość <code>__proto__</code>, tam metoda <code>valueOf()</code> istnieje i pochodzi z <code>Object.prototype</code>. Dopiero z tego prototypu jest wywoływana.</p><p>Tak wygląda proces wywoływania właściwości i ich poszukiwania. Jeżeli nie istnieją one w głównym obiekcie, zawsze następuje proces poszukiwania w odziedziczonych prototypach, aż do ostatniego prototypu pochodzącego z <code>Object.prototype</code>. Takie połączenie nazywamy łańcuchem prototypów.</p><h2 id="stworzenie-własnego-prototypu" tabindex="-1"><a class="header-anchor" href="#stworzenie-własnego-prototypu" aria-hidden="true">#</a> Stworzenie własnego prototypu</h2><p>Do tej pory pokazywałem przykłady, które wykorzystują gotowe prototypy w JavaScript. W dziale o obiektach, pokazywałem natomiast metodę <code>Object.create</code>, która pozwala stworzyć obiekt na podstawie innego obiektu:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&#39;John&#39;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> soldier <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  surname<span class="token operator">:</span> <span class="token punctuation">{</span>\n    value<span class="token operator">:</span> <span class="token string">&#39;Rambo&#39;</span><span class="token punctuation">,</span>\n    writabe<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>Na początek tworzę zwykły obiekt, który będzie posiadał pole <code>name</code>. Potem wykorzystuję metodę <code>Object.create</code> do której jako pierwszy parametr podaję stworzony obiekt. To ten obiekt będzie teraz prototypem dla tworzonego obiektu <code>solider</code>. Tworzę też nowe pole o nazwie <code>surname</code> i przekazuję konfigurację dla deskryptora. Przy metodzie <code>Object.create</code> konfigurację należy uzupełnić samemu, albo wszystko będzie ustawione na <code>false</code>.</p><p>Gdy wypiszemy obiekt do konsoli:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>soldier<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>zobaczymy, że pod właściwością <code>__proto__</code> znajduje się obiekt <code>person</code>:</p><div class="language-powershell ext-powershell line-numbers-mode"><pre class="language-powershell"><code>__proto__:\nname: <span class="token string">&quot;John&quot;</span>\nprint: ƒ print<span class="token punctuation">(</span><span class="token punctuation">)</span>\n__proto__: Object\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Teraz pierwszym prototypem dla naszego obiektu jest nasz stworzony obiekt. Ma on jednak swoją właściwość <code>__proto__</code> i tam jest już prototyp z <code>Object.prototype</code>. Utworzył się więc łańcuch prototypów.</p><p>W naszym obiekcie <code>soldier</code>, nie istnieje pole <code>name</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>soldier<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// John</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Jeżeli odwołam się do pola <code>name</code>, to i tak otrzymam wartość. JavaScript sprawdzi, że pole to nie jest dostępne w naszym podstawowym obiekcie i będzie po kolei przeszukiwał kolejne właściwości <code>[[Prototype]]</code>, aż natrafi na to pole i zwróci wartość.</p><p>Na tym przykładzie widzimy, że prototyp obiektu to ta naprawdę inny obiekt. Możemy sami stworzyć obiekt, który będzie prototypem. Natomiast na końcu łańcucha prototypów i tak zawsz znajduje się <code>Objec.prototype</code> jako baza dla każdego obiektu w JavaScript.</p><p>Wyjątkiem jest oczywiście sytuacja, gdy do metody <code>Object.create</code> przekażemy wartość <code>null</code>.</p><h2 id="co-warto-zapamietac" tabindex="-1"><a class="header-anchor" href="#co-warto-zapamietac" aria-hidden="true">#</a> Co warto zapamiętać:</h2><ul><li>obiekty mogą posiadać łańcuch prototypów</li><li>na końcu łańcucha prototypów jest zawsze <code>Object.prototype</code></li><li>możemy sami stworzyć obiekt, który będzie prototypem dla kolejnych obiektów przez<code>Object.create</code></li><li>wewnętrzna właściwość <code>[[Prototype]]</code> zawsze ma przypisany jakiś obiekt lub wartość <code>null</code>, nie może przyjąć innej wartości</li></ul>',29),s={},t=(0,o(3744).Z)(s,[["render",function(a,n){return e}]])},3744:(a,n)=>{n.Z=(a,n)=>{for(const[o,e]of n)a[o]=e;return a}}}]);